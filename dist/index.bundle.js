/*! For license information please see index.bundle.js.LICENSE.txt */
(()=>{var e,t,r,n,a={265:(e,t,r)=>{"use strict";e=r.nmd(e);const n=(e=0)=>t=>`[${38+e};5;${t}m`,a=(e=0)=>(t,r,n)=>`[${38+e};2;${t};${r};${n}m`;Object.defineProperty(e,"exports",{enumerable:!0,get:function(){const e=new Map,t={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};t.color.gray=t.color.blackBright,t.bgColor.bgGray=t.bgColor.bgBlackBright,t.color.grey=t.color.blackBright,t.bgColor.bgGrey=t.bgColor.bgBlackBright;for(const[r,n]of Object.entries(t)){for(const[r,a]of Object.entries(n))t[r]={open:`[${a[0]}m`,close:`[${a[1]}m`},n[r]=t[r],e.set(a[0],a[1]);Object.defineProperty(t,r,{value:n,enumerable:!1})}return Object.defineProperty(t,"codes",{value:e,enumerable:!1}),t.color.close="[39m",t.bgColor.close="[49m",t.color.ansi256=n(),t.color.ansi16m=a(),t.bgColor.ansi256=n(10),t.bgColor.ansi16m=a(10),Object.defineProperties(t,{rgbToAnsi256:{value:(e,t,r)=>e===t&&t===r?e<8?16:e>248?231:Math.round((e-8)/247*24)+232:16+36*Math.round(e/255*5)+6*Math.round(t/255*5)+Math.round(r/255*5),enumerable:!1},hexToRgb:{value:e=>{const t=/(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(e.toString(16));if(!t)return[0,0,0];let{colorString:r}=t.groups;3===r.length&&(r=r.split("").map((e=>e+e)).join(""));const n=Number.parseInt(r,16);return[n>>16&255,n>>8&255,255&n]},enumerable:!1},hexToAnsi256:{value:e=>t.rgbToAnsi256(...t.hexToRgb(e)),enumerable:!1}}),t}})},742:(e,t)=>{"use strict";t.byteLength=function(e){var t=l(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,i=l(e),s=i[0],o=i[1],c=new a(function(e,t,r){return 3*(t+r)/4-r}(0,s,o)),u=0,h=o>0?s-4:s;for(r=0;r<h;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],c[u++]=t>>16&255,c[u++]=t>>8&255,c[u++]=255&t;return 2===o&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,c[u++]=255&t),1===o&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,c[u++]=t>>8&255,c[u++]=255&t),c},t.fromByteArray=function(e){for(var t,n=e.length,a=n%3,i=[],s=16383,o=0,l=n-a;o<l;o+=s)i.push(c(e,o,o+s>l?l:o+s));return 1===a?(t=e[n-1],i.push(r[t>>2]+r[t<<4&63]+"==")):2===a&&(t=(e[n-2]<<8)+e[n-1],i.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"=")),i.join("")};for(var r=[],n=[],a="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,o=i.length;s<o;++s)r[s]=i[s],n[i.charCodeAt(s)]=s;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function c(e,t,n){for(var a,i,s=[],o=t;o<n;o+=3)a=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),s.push(r[(i=a)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return s.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},204:e=>{"use strict";const t=/[\p{Lu}]/u,r=/[\p{Ll}]/u,n=/^[\p{Lu}](?![\p{Lu}])/gu,a=/([\p{Alpha}\p{N}_]|$)/u,i=/[_.\- ]+/,s=new RegExp("^"+i.source),o=new RegExp(i.source+a.source,"gu"),l=new RegExp("\\d+"+a.source,"gu"),c=(e,a)=>{if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("Expected the input to be `string | string[]`");if(a={pascalCase:!1,preserveConsecutiveUppercase:!1,...a},0===(e=Array.isArray(e)?e.map((e=>e.trim())).filter((e=>e.length)).join("-"):e.trim()).length)return"";const i=!1===a.locale?e=>e.toLowerCase():e=>e.toLocaleLowerCase(a.locale),c=!1===a.locale?e=>e.toUpperCase():e=>e.toLocaleUpperCase(a.locale);return 1===e.length?a.pascalCase?c(e):i(e):(e!==i(e)&&(e=((e,n,a)=>{let i=!1,s=!1,o=!1;for(let l=0;l<e.length;l++){const c=e[l];i&&t.test(c)?(e=e.slice(0,l)+"-"+e.slice(l),i=!1,o=s,s=!0,l++):s&&o&&r.test(c)?(e=e.slice(0,l-1)+"-"+e.slice(l-1),o=s,s=!1,i=!0):(i=n(c)===c&&a(c)!==c,o=s,s=a(c)===c&&n(c)!==c)}return e})(e,i,c)),e=e.replace(s,""),e=a.preserveConsecutiveUppercase?((e,t)=>(n.lastIndex=0,e.replace(n,(e=>t(e)))))(e,i):i(e),a.pascalCase&&(e=c(e.charAt(0))+e.slice(1)),((e,t)=>(o.lastIndex=0,l.lastIndex=0,e.replace(o,((e,r)=>t(r))).replace(l,(e=>t(e)))))(e,c))};e.exports=c,e.exports.default=c},466:e=>{"use strict";e.exports=function(e,t){if("string"!=typeof e)throw new TypeError("Expected a string");return t=void 0===t?"_":t,e.replace(/([a-z\d])([A-Z])/g,"$1"+t+"$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g,"$1"+t+"$2").toLowerCase()}},729:e=>{"use strict";var t=Object.prototype.hasOwnProperty,r="~";function n(){}function a(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function i(e,t,n,i,s){if("function"!=typeof n)throw new TypeError("The listener must be a function");var o=new a(n,i||e,s),l=r?r+t:t;return e._events[l]?e._events[l].fn?e._events[l]=[e._events[l],o]:e._events[l].push(o):(e._events[l]=o,e._eventsCount++),e}function s(e,t){0==--e._eventsCount?e._events=new n:delete e._events[t]}function o(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),o.prototype.eventNames=function(){var e,n,a=[];if(0===this._eventsCount)return a;for(n in e=this._events)t.call(e,n)&&a.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?a.concat(Object.getOwnPropertySymbols(e)):a},o.prototype.listeners=function(e){var t=r?r+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var a=0,i=n.length,s=new Array(i);a<i;a++)s[a]=n[a].fn;return s},o.prototype.listenerCount=function(e){var t=r?r+e:e,n=this._events[t];return n?n.fn?1:n.length:0},o.prototype.emit=function(e,t,n,a,i,s){var o=r?r+e:e;if(!this._events[o])return!1;var l,c,u=this._events[o],h=arguments.length;if(u.fn){switch(u.once&&this.removeListener(e,u.fn,void 0,!0),h){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,t),!0;case 3:return u.fn.call(u.context,t,n),!0;case 4:return u.fn.call(u.context,t,n,a),!0;case 5:return u.fn.call(u.context,t,n,a,i),!0;case 6:return u.fn.call(u.context,t,n,a,i,s),!0}for(c=1,l=new Array(h-1);c<h;c++)l[c-1]=arguments[c];u.fn.apply(u.context,l)}else{var d,p=u.length;for(c=0;c<p;c++)switch(u[c].once&&this.removeListener(e,u[c].fn,void 0,!0),h){case 1:u[c].fn.call(u[c].context);break;case 2:u[c].fn.call(u[c].context,t);break;case 3:u[c].fn.call(u[c].context,t,n);break;case 4:u[c].fn.call(u[c].context,t,n,a);break;default:if(!l)for(d=1,l=new Array(h-1);d<h;d++)l[d-1]=arguments[d];u[c].fn.apply(u[c].context,l)}}return!0},o.prototype.on=function(e,t,r){return i(this,e,t,r,!1)},o.prototype.once=function(e,t,r){return i(this,e,t,r,!0)},o.prototype.removeListener=function(e,t,n,a){var i=r?r+e:e;if(!this._events[i])return this;if(!t)return s(this,i),this;var o=this._events[i];if(o.fn)o.fn!==t||a&&!o.once||n&&o.context!==n||s(this,i);else{for(var l=0,c=[],u=o.length;l<u;l++)(o[l].fn!==t||a&&!o[l].once||n&&o[l].context!==n)&&c.push(o[l]);c.length?this._events[i]=1===c.length?c[0]:c:s(this,i)}return this},o.prototype.removeAllListeners=function(e){var t;return e?(t=r?r+e:e,this._events[t]&&s(this,t)):(this._events=new n,this._eventsCount=0),this},o.prototype.off=o.prototype.removeListener,o.prototype.addListener=o.prototype.on,o.prefixed=r,o.EventEmitter=o,e.exports=o},345:e=>{"use strict";e.exports=(e,t)=>(t=t||(()=>{}),e.then((e=>new Promise((e=>{e(t())})).then((()=>e))),(e=>new Promise((e=>{e(t())})).then((()=>{throw e})))))},860:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(729),a=r(147),i=r(506),s=()=>{},o=new a.TimeoutError;t.default=class extends n{constructor(e){var t,r,n,a;if(super(),this._intervalCount=0,this._intervalEnd=0,this._pendingCount=0,this._resolveEmpty=s,this._resolveIdle=s,!("number"==typeof(e=Object.assign({carryoverConcurrencyCount:!1,intervalCap:1/0,interval:0,concurrency:1/0,autoStart:!0,queueClass:i.default},e)).intervalCap&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${null!==(r=null===(t=e.intervalCap)||void 0===t?void 0:t.toString())&&void 0!==r?r:""}\` (${typeof e.intervalCap})`);if(void 0===e.interval||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${null!==(a=null===(n=e.interval)||void 0===n?void 0:n.toString())&&void 0!==a?a:""}\` (${typeof e.interval})`);this._carryoverConcurrencyCount=e.carryoverConcurrencyCount,this._isIntervalIgnored=e.intervalCap===1/0||0===e.interval,this._intervalCap=e.intervalCap,this._interval=e.interval,this._queue=new e.queueClass,this._queueClass=e.queueClass,this.concurrency=e.concurrency,this._timeout=e.timeout,this._throwOnTimeout=!0===e.throwOnTimeout,this._isPaused=!1===e.autoStart}get _doesIntervalAllowAnother(){return this._isIntervalIgnored||this._intervalCount<this._intervalCap}get _doesConcurrentAllowAnother(){return this._pendingCount<this._concurrency}_next(){this._pendingCount--,this._tryToStartAnother(),this.emit("next")}_resolvePromises(){this._resolveEmpty(),this._resolveEmpty=s,0===this._pendingCount&&(this._resolveIdle(),this._resolveIdle=s,this.emit("idle"))}_onResumeInterval(){this._onInterval(),this._initializeIntervalIfNeeded(),this._timeoutId=void 0}_isIntervalPaused(){const e=Date.now();if(void 0===this._intervalId){const t=this._intervalEnd-e;if(!(t<0))return void 0===this._timeoutId&&(this._timeoutId=setTimeout((()=>{this._onResumeInterval()}),t)),!0;this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0}return!1}_tryToStartAnother(){if(0===this._queue.size)return this._intervalId&&clearInterval(this._intervalId),this._intervalId=void 0,this._resolvePromises(),!1;if(!this._isPaused){const e=!this._isIntervalPaused();if(this._doesIntervalAllowAnother&&this._doesConcurrentAllowAnother){const t=this._queue.dequeue();return!!t&&(this.emit("active"),t(),e&&this._initializeIntervalIfNeeded(),!0)}}return!1}_initializeIntervalIfNeeded(){this._isIntervalIgnored||void 0!==this._intervalId||(this._intervalId=setInterval((()=>{this._onInterval()}),this._interval),this._intervalEnd=Date.now()+this._interval)}_onInterval(){0===this._intervalCount&&0===this._pendingCount&&this._intervalId&&(clearInterval(this._intervalId),this._intervalId=void 0),this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0,this._processQueue()}_processQueue(){for(;this._tryToStartAnother(););}get concurrency(){return this._concurrency}set concurrency(e){if(!("number"==typeof e&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this._concurrency=e,this._processQueue()}async add(e,t={}){return new Promise(((r,n)=>{this._queue.enqueue((async()=>{this._pendingCount++,this._intervalCount++;try{const i=void 0===this._timeout&&void 0===t.timeout?e():a.default(Promise.resolve(e()),void 0===t.timeout?this._timeout:t.timeout,(()=>{(void 0===t.throwOnTimeout?this._throwOnTimeout:t.throwOnTimeout)&&n(o)}));r(await i)}catch(e){n(e)}this._next()}),t),this._tryToStartAnother(),this.emit("add")}))}async addAll(e,t){return Promise.all(e.map((async e=>this.add(e,t))))}start(){return this._isPaused?(this._isPaused=!1,this._processQueue(),this):this}pause(){this._isPaused=!0}clear(){this._queue=new this._queueClass}async onEmpty(){if(0!==this._queue.size)return new Promise((e=>{const t=this._resolveEmpty;this._resolveEmpty=()=>{t(),e()}}))}async onIdle(){if(0!==this._pendingCount||0!==this._queue.size)return new Promise((e=>{const t=this._resolveIdle;this._resolveIdle=()=>{t(),e()}}))}get size(){return this._queue.size}sizeBy(e){return this._queue.filter(e).length}get pending(){return this._pendingCount}get isPaused(){return this._isPaused}get timeout(){return this._timeout}set timeout(e){this._timeout=e}}},489:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){let n=0,a=e.length;for(;a>0;){const i=a/2|0;let s=n+i;r(e[s],t)<=0?(n=++s,a-=i+1):a=i}return n}},506:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(489);t.default=class{constructor(){this._queue=[]}enqueue(e,t){const r={priority:(t=Object.assign({priority:0},t)).priority,run:e};if(this.size&&this._queue[this.size-1].priority>=t.priority)return void this._queue.push(r);const a=n.default(this._queue,r,((e,t)=>t.priority-e.priority));this._queue.splice(a,0,r)}dequeue(){const e=this._queue.shift();return null==e?void 0:e.run}filter(e){return this._queue.filter((t=>t.priority===e.priority)).map((e=>e.run))}get size(){return this._queue.length}}},693:(e,t,r)=>{"use strict";const n=r(837),a=["Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed"];class i extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,({message:e}=e)):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const s=(e,t)=>new Promise(((r,s)=>{t={onFailedAttempt:()=>{},retries:10,...t};const o=n.operation(t);o.attempt((async n=>{try{r(await e(n))}catch(e){if(!(e instanceof Error))return void s(new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`));if(e instanceof i)o.stop(),s(e.originalError);else if(e instanceof TypeError&&(l=e.message,!a.includes(l)))o.stop(),s(e);else{((e,t,r)=>{const n=r.retries-(t-1);e.attemptNumber=t,e.retriesLeft=n})(e,n,t);try{await t.onFailedAttempt(e)}catch(e){return void s(e)}o.retry(e)||s(o.mainError())}}var l}))}));e.exports=s,e.exports.default=s,e.exports.AbortError=i},837:(e,t,r)=>{e.exports=r(280)},280:(e,t,r)=>{var n=r(793);t.operation=function(e){var r=t.timeouts(e);return new n(r,{forever:e&&(e.forever||e.retries===1/0),unref:e&&e.unref,maxRetryTime:e&&e.maxRetryTime})},t.timeouts=function(e){if(e instanceof Array)return[].concat(e);var t={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var r in e)t[r]=e[r];if(t.minTimeout>t.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var n=[],a=0;a<t.retries;a++)n.push(this.createTimeout(a,t));return e&&e.forever&&!n.length&&n.push(this.createTimeout(a,t)),n.sort((function(e,t){return e-t})),n},t.createTimeout=function(e,t){var r=t.randomize?Math.random()+1:1,n=Math.round(r*Math.max(t.minTimeout,1)*Math.pow(t.factor,e));return Math.min(n,t.maxTimeout)},t.wrap=function(e,r,n){if(r instanceof Array&&(n=r,r=null),!n)for(var a in n=[],e)"function"==typeof e[a]&&n.push(a);for(var i=0;i<n.length;i++){var s=n[i],o=e[s];e[s]=function(n){var a=t.operation(r),i=Array.prototype.slice.call(arguments,1),s=i.pop();i.push((function(e){a.retry(e)||(e&&(arguments[0]=a.mainError()),s.apply(this,arguments))})),a.attempt((function(){n.apply(e,i)}))}.bind(e,o),e[s].options=r}}},793:e=>{function t(e,t){"boolean"==typeof t&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}e.exports=t,t.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},t.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},t.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=(new Date).getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var r=this._timeouts.shift();if(void 0===r){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1)}var n=this;return this._timer=setTimeout((function(){n._attempts++,n._operationTimeoutCb&&(n._timeout=setTimeout((function(){n._operationTimeoutCb(n._attempts)}),n._operationTimeout),n._options.unref&&n._timeout.unref()),n._fn(n._attempts)}),r),this._options.unref&&this._timer.unref(),!0},t.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout((function(){r._operationTimeoutCb()}),r._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},t.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},t.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},t.prototype.start=t.prototype.try,t.prototype.errors=function(){return this._errors},t.prototype.attempts=function(){return this._attempts},t.prototype.mainError=function(){if(0===this._errors.length)return null;for(var e={},t=null,r=0,n=0;n<this._errors.length;n++){var a=this._errors[n],i=a.message,s=(e[i]||0)+1;e[i]=s,s>=r&&(t=a,r=s)}return t}},147:(e,t,r)=>{"use strict";const n=r(345);class a extends Error{constructor(e){super(e),this.name="TimeoutError"}}const i=(e,t,r)=>new Promise(((i,s)=>{if("number"!=typeof t||t<0)throw new TypeError("Expected `milliseconds` to be a positive number");if(t===1/0)return void i(e);const o=setTimeout((()=>{if("function"==typeof r){try{i(r())}catch(e){s(e)}return}const n=r instanceof Error?r:new a("string"==typeof r?r:`Promise timed out after ${t} milliseconds`);"function"==typeof e.cancel&&e.cancel(),s(n)}),t);n(e.then(i,s),(()=>{clearTimeout(o)}))}));e.exports=i,e.exports.default=i,e.exports.TimeoutError=a},138:(e,t,r)=>{"use strict";r.a(e,(async(e,t)=>{try{var n=r(440);try{const e=await fetch("../scrimba-info.txt"),t=await e.text(),r=new n.s9({chunkSize:500,separators:["\n\n","\n"," ",""],chunkOverlap:50}),a=await r.createDocuments([t]);console.log(a)}catch(e){console.log(e)}t()}catch(e){t(e)}}),1)},440:(e,t,r)=>{"use strict";r.d(t,{s9:()=>lt});var n={};r.r(n),r.d(n,{JsonPatchError:()=>ye,_areEquals:()=>xe,applyOperation:()=>Te,applyPatch:()=>Se,applyReducer:()=>Ce,deepClone:()=>_e,getValueByPointer:()=>Oe,validate:()=>je,validator:()=>Ae});class a{constructor(e){Object.defineProperty(this,"pageContent",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.pageContent=e.pageContent?e.pageContent.toString():this.pageContent,this.metadata=e.metadata??{}}}var i=r(693);const s={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let o;const l=new Uint8Array(16);function c(){if(!o&&(o="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!o))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return o(l)}const u=[];for(let e=0;e<256;++e)u.push((e+256).toString(16).slice(1));const h=function(e,t,r){if(s.randomUUID&&!t&&!e)return s.randomUUID();const n=(e=e||{}).random||(e.rng||c)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,t){r=r||0;for(let e=0;e<16;++e)t[r+e]=n[e];return t}return function(e,t=0){return u[e[t+0]]+u[e[t+1]]+u[e[t+2]]+u[e[t+3]]+"-"+u[e[t+4]]+u[e[t+5]]+"-"+u[e[t+6]]+u[e[t+7]]+"-"+u[e[t+8]]+u[e[t+9]]+"-"+u[e[t+10]]+u[e[t+11]]+u[e[t+12]]+u[e[t+13]]+u[e[t+14]]+u[e[t+15]]}(n)};var d=r(466);function p(e,t){return t?.[e]||d(e)}function f(e,t,r){const n={};for(const a in e)Object.hasOwn(e,a)&&(n[t(a,r)]=e[a]);return n}function m(e){return Array.isArray(e)?[...e]:{...e}}function g(e,t){const r=m(e);for(const[e,n]of Object.entries(t)){const[t,...a]=e.split(".").reverse();let i=r;for(const e of a.reverse()){if(void 0===i[e])break;i[e]=m(i[e]),i=i[e]}void 0!==i[t]&&(i[t]={lc:1,type:"secret",id:[n]})}return r}function b(e){const t=Object.getPrototypeOf(e);return"function"!=typeof e.lc_name||"function"==typeof t.lc_name&&e.lc_name()===t.lc_name()?e.name:e.lc_name()}r(204);class w{static lc_name(){return this.name}get lc_id(){return[...this.lc_namespace,b(this.constructor)]}get lc_secrets(){}get lc_attributes(){}get lc_aliases(){}constructor(e,...t){Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.lc_kwargs=e||{}}toJSON(){if(!this.lc_serializable)return this.toJSONNotImplemented();if(this.lc_kwargs instanceof w||"object"!=typeof this.lc_kwargs||Array.isArray(this.lc_kwargs))return this.toJSONNotImplemented();const e={},t={},r=Object.keys(this.lc_kwargs).reduce(((e,t)=>(e[t]=t in this?this[t]:this.lc_kwargs[t],e)),{});for(let n=Object.getPrototypeOf(this);n;n=Object.getPrototypeOf(n))Object.assign(e,Reflect.get(n,"lc_aliases",this)),Object.assign(t,Reflect.get(n,"lc_secrets",this)),Object.assign(r,Reflect.get(n,"lc_attributes",this));return Object.keys(t).forEach((e=>{let t=this,n=r;const[a,...i]=e.split(".").reverse();for(const e of i.reverse()){if(!(e in t)||void 0===t[e])return;e in n&&void 0!==n[e]||("object"==typeof t[e]&&null!=t[e]?n[e]={}:Array.isArray(t[e])&&(n[e]=[])),t=t[e],n=n[e]}a in t&&void 0!==t[a]&&(n[a]=n[a]||t[a])})),{lc:1,type:"constructor",id:this.lc_id,kwargs:f(Object.keys(t).length?g(r,t):r,p,e)}}toJSONNotImplemented(){return{lc:1,type:"not_implemented",id:this.lc_id}}}class y extends class{}{get lc_namespace(){return["langchain_core","callbacks",this.name]}get lc_secrets(){}get lc_attributes(){}get lc_aliases(){}static lc_name(){return this.name}get lc_id(){return[...this.lc_namespace,b(this.constructor)]}constructor(e){super(),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"ignoreLLM",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreChain",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreAgent",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreRetriever",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"awaitHandlers",{enumerable:!0,configurable:!0,writable:!0,value:"undefined"==typeof process||"true"!==process.env?.LANGCHAIN_CALLBACKS_BACKGROUND}),this.lc_kwargs=e||{},e&&(this.ignoreLLM=e.ignoreLLM??this.ignoreLLM,this.ignoreChain=e.ignoreChain??this.ignoreChain,this.ignoreAgent=e.ignoreAgent??this.ignoreAgent,this.ignoreRetriever=e.ignoreRetriever??this.ignoreRetriever)}copy(){return new this.constructor(this)}toJSON(){return w.prototype.toJSON.call(this)}toJSONNotImplemented(){return w.prototype.toJSONNotImplemented.call(this)}static fromMethods(e){return new class extends y{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:h()}),Object.assign(this,e)}}}}var _=r(265);function v(e,t){return e&&!Array.isArray(e)&&"object"==typeof e?e:{[t]:e}}class E extends y{constructor(e){super(...arguments),Object.defineProperty(this,"runMap",{enumerable:!0,configurable:!0,writable:!0,value:new Map})}copy(){return this}_addChildRun(e,t){e.child_runs.push(t)}async _startTrace(e){const t=(r=e.start_time,n=e.id,`${new Date(r).toISOString().slice(0,-1)}000Z`.replace(/[-:.]/g,"")+n);var r,n;const a={...e};if(void 0!==a.parent_run_id){const e=this.runMap.get(a.parent_run_id);e&&(this._addChildRun(e,a),e.child_execution_order=Math.max(e.child_execution_order,a.child_execution_order),a.trace_id=e.trace_id,void 0!==e.dotted_order?a.dotted_order=[e.dotted_order,t].join("."):console.warn(`Parent run with UUID ${a.parent_run_id} not found.`))}else a.trace_id=a.id,a.dotted_order=t;this.runMap.set(a.id,a),await(this.onRunCreate?.(a))}async _endTrace(e){const t=void 0!==e.parent_run_id&&this.runMap.get(e.parent_run_id);t?t.child_execution_order=Math.max(t.child_execution_order,e.child_execution_order):await this.persistRun(e),this.runMap.delete(e.id),await(this.onRunUpdate?.(e))}_getExecutionOrder(e){const t=void 0!==e&&this.runMap.get(e);return t?t.child_execution_order+1:1}async handleLLMStart(e,t,r,n,a,i,s,o){const l=this._getExecutionOrder(n),c=Date.now(),u=s?{...a,metadata:s}:a,h={id:r,name:o??e.id[e.id.length-1],parent_run_id:n,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:{prompts:t},execution_order:l,child_runs:[],child_execution_order:l,run_type:"llm",extra:u??{},tags:i||[]};return await this._startTrace(h),await(this.onLLMStart?.(h)),h}async handleChatModelStart(e,t,r,n,a,i,s,o){const l=this._getExecutionOrder(n),c=Date.now(),u=s?{...a,metadata:s}:a,h={id:r,name:o??e.id[e.id.length-1],parent_run_id:n,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:{messages:t},execution_order:l,child_runs:[],child_execution_order:l,run_type:"llm",extra:u??{},tags:i||[]};return await this._startTrace(h),await(this.onLLMStart?.(h)),h}async handleLLMEnd(e,t){const r=this.runMap.get(t);if(!r||"llm"!==r?.run_type)throw new Error("No LLM run to end.");return r.end_time=Date.now(),r.outputs=e,r.events.push({name:"end",time:new Date(r.end_time).toISOString()}),await(this.onLLMEnd?.(r)),await this._endTrace(r),r}async handleLLMError(e,t){const r=this.runMap.get(t);if(!r||"llm"!==r?.run_type)throw new Error("No LLM run to end.");return r.end_time=Date.now(),r.error=e.message,r.events.push({name:"error",time:new Date(r.end_time).toISOString()}),await(this.onLLMError?.(r)),await this._endTrace(r),r}async handleChainStart(e,t,r,n,a,i,s,o){const l=this._getExecutionOrder(n),c=Date.now(),u={id:r,name:o??e.id[e.id.length-1],parent_run_id:n,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:t,execution_order:l,child_execution_order:l,run_type:s??"chain",child_runs:[],extra:i?{metadata:i}:{},tags:a||[]};return await this._startTrace(u),await(this.onChainStart?.(u)),u}async handleChainEnd(e,t,r,n,a){const i=this.runMap.get(t);if(!i)throw new Error("No chain run to end.");return i.end_time=Date.now(),i.outputs=v(e,"output"),i.events.push({name:"end",time:new Date(i.end_time).toISOString()}),void 0!==a?.inputs&&(i.inputs=v(a.inputs,"input")),await(this.onChainEnd?.(i)),await this._endTrace(i),i}async handleChainError(e,t,r,n,a){const i=this.runMap.get(t);if(!i)throw new Error("No chain run to end.");return i.end_time=Date.now(),i.error=e.message,i.events.push({name:"error",time:new Date(i.end_time).toISOString()}),void 0!==a?.inputs&&(i.inputs=v(a.inputs,"input")),await(this.onChainError?.(i)),await this._endTrace(i),i}async handleToolStart(e,t,r,n,a,i,s){const o=this._getExecutionOrder(n),l=Date.now(),c={id:r,name:s??e.id[e.id.length-1],parent_run_id:n,start_time:l,serialized:e,events:[{name:"start",time:new Date(l).toISOString()}],inputs:{input:t},execution_order:o,child_execution_order:o,run_type:"tool",child_runs:[],extra:i?{metadata:i}:{},tags:a||[]};return await this._startTrace(c),await(this.onToolStart?.(c)),c}async handleToolEnd(e,t){const r=this.runMap.get(t);if(!r||"tool"!==r?.run_type)throw new Error("No tool run to end");return r.end_time=Date.now(),r.outputs={output:e},r.events.push({name:"end",time:new Date(r.end_time).toISOString()}),await(this.onToolEnd?.(r)),await this._endTrace(r),r}async handleToolError(e,t){const r=this.runMap.get(t);if(!r||"tool"!==r?.run_type)throw new Error("No tool run to end");return r.end_time=Date.now(),r.error=e.message,r.events.push({name:"error",time:new Date(r.end_time).toISOString()}),await(this.onToolError?.(r)),await this._endTrace(r),r}async handleAgentAction(e,t){const r=this.runMap.get(t);if(!r||"chain"!==r?.run_type)return;const n=r;n.actions=n.actions||[],n.actions.push(e),n.events.push({name:"agent_action",time:(new Date).toISOString(),kwargs:{action:e}}),await(this.onAgentAction?.(r))}async handleAgentEnd(e,t){const r=this.runMap.get(t);r&&"chain"===r?.run_type&&(r.events.push({name:"agent_end",time:(new Date).toISOString(),kwargs:{action:e}}),await(this.onAgentEnd?.(r)))}async handleRetrieverStart(e,t,r,n,a,i,s){const o=this._getExecutionOrder(n),l=Date.now(),c={id:r,name:s??e.id[e.id.length-1],parent_run_id:n,start_time:l,serialized:e,events:[{name:"start",time:new Date(l).toISOString()}],inputs:{query:t},execution_order:o,child_execution_order:o,run_type:"retriever",child_runs:[],extra:i?{metadata:i}:{},tags:a||[]};return await this._startTrace(c),await(this.onRetrieverStart?.(c)),c}async handleRetrieverEnd(e,t){const r=this.runMap.get(t);if(!r||"retriever"!==r?.run_type)throw new Error("No retriever run to end");return r.end_time=Date.now(),r.outputs={documents:e},r.events.push({name:"end",time:new Date(r.end_time).toISOString()}),await(this.onRetrieverEnd?.(r)),await this._endTrace(r),r}async handleRetrieverError(e,t){const r=this.runMap.get(t);if(!r||"retriever"!==r?.run_type)throw new Error("No retriever run to end");return r.end_time=Date.now(),r.error=e.message,r.events.push({name:"error",time:new Date(r.end_time).toISOString()}),await(this.onRetrieverError?.(r)),await this._endTrace(r),r}async handleText(e,t){const r=this.runMap.get(t);r&&"chain"===r?.run_type&&(r.events.push({name:"text",time:(new Date).toISOString(),kwargs:{text:e}}),await(this.onText?.(r)))}async handleLLMNewToken(e,t,r,n,a,i){const s=this.runMap.get(r);if(!s||"llm"!==s?.run_type)throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');return s.events.push({name:"new_token",time:(new Date).toISOString(),kwargs:{token:e,idx:t,chunk:i?.chunk}}),await(this.onLLMNewToken?.(s,e)),s}}function O(e,t){return`${e.open}${t}${e.close}`}function T(e,t){try{return JSON.stringify(e,null,2)}catch(e){return t}}function S(e){if(!e.end_time)return"";const t=e.end_time-e.start_time;return t<1e3?`${t}ms`:`${(t/1e3).toFixed(2)}s`}const{color:C}=_;class A extends E{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"console_callback_handler"})}persistRun(e){return Promise.resolve()}getParents(e){const t=[];let r=e;for(;r.parent_run_id;){const e=this.runMap.get(r.parent_run_id);if(!e)break;t.push(e),r=e}return t}getBreadcrumbs(e){const t=[...this.getParents(e).reverse(),e].map(((e,t,r)=>{const n=`${e.execution_order}:${e.run_type}:${e.name}`;return t===r.length-1?O(_.bold,n):n})).join(" > ");return O(C.grey,t)}onChainStart(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.green,"[chain/start]")} [${t}] Entering Chain run with input: ${T(e.inputs,"[inputs]")}`)}onChainEnd(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.cyan,"[chain/end]")} [${t}] [${S(e)}] Exiting Chain run with output: ${T(e.outputs,"[outputs]")}`)}onChainError(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.red,"[chain/error]")} [${t}] [${S(e)}] Chain run errored with error: ${T(e.error,"[error]")}`)}onLLMStart(e){const t=this.getBreadcrumbs(e),r="prompts"in e.inputs?{prompts:e.inputs.prompts.map((e=>e.trim()))}:e.inputs;console.log(`${O(C.green,"[llm/start]")} [${t}] Entering LLM run with input: ${T(r,"[inputs]")}`)}onLLMEnd(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.cyan,"[llm/end]")} [${t}] [${S(e)}] Exiting LLM run with output: ${T(e.outputs,"[response]")}`)}onLLMError(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.red,"[llm/error]")} [${t}] [${S(e)}] LLM run errored with error: ${T(e.error,"[error]")}`)}onToolStart(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.green,"[tool/start]")} [${t}] Entering Tool run with input: "${e.inputs.input?.trim()}"`)}onToolEnd(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.cyan,"[tool/end]")} [${t}] [${S(e)}] Exiting Tool run with output: "${e.outputs?.output?.trim()}"`)}onToolError(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.red,"[tool/error]")} [${t}] [${S(e)}] Tool run errored with error: ${T(e.error,"[error]")}`)}onRetrieverStart(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.green,"[retriever/start]")} [${t}] Entering Retriever run with input: ${T(e.inputs,"[inputs]")}`)}onRetrieverEnd(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.cyan,"[retriever/end]")} [${t}] [${S(e)}] Exiting Retriever run with output: ${T(e.outputs,"[outputs]")}`)}onRetrieverError(e){const t=this.getBreadcrumbs(e);console.log(`${O(C.red,"[retriever/error]")} [${t}] [${S(e)}] Retriever run errored with error: ${T(e.error,"[error]")}`)}onAgentAction(e){const t=e,r=this.getBreadcrumbs(e);console.log(`${O(C.blue,"[agent/action]")} [${r}] Agent selected action: ${T(t.actions[t.actions.length-1],"[action]")}`)}}const j=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,x={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let I;const k=new Uint8Array(16);function P(){if(!I&&(I="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!I))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return I(k)}const R=[];for(let e=0;e<256;++e)R.push((e+256).toString(16).slice(1));const $=function(e,t,r){if(x.randomUUID&&!t&&!e)return x.randomUUID();const n=(e=e||{}).random||(e.rng||P)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,t){r=r||0;for(let e=0;e<16;++e)t[r+e]=n[e];return t}return function(e,t=0){return R[e[t+0]]+R[e[t+1]]+R[e[t+2]]+R[e[t+3]]+"-"+R[e[t+4]]+R[e[t+5]]+"-"+R[e[t+6]]+R[e[t+7]]+"-"+R[e[t+8]]+R[e[t+9]]+"-"+R[e[t+10]]+R[e[t+11]]+R[e[t+12]]+R[e[t+13]]+R[e[t+14]]+R[e[t+15]]}(n)};var N=r(860);const L=[400,401,403,404,405,406,407,408,409];class M{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6;const t=N.default;this.queue=new t({concurrency:this.maxConcurrency})}call(e,...t){return this.queue.add((()=>i((()=>e(...t).catch((e=>{throw e instanceof Error?e:new Error(e)}))),{onFailedAttempt(e){if(e.message.startsWith("Cancel")||e.message.startsWith("TimeoutError")||e.message.startsWith("AbortError"))throw e;if("ECONNABORTED"===e?.code)throw e;const t=e?.response?.status;if(t&&L.includes(+t))throw e},retries:this.maxRetries,randomize:!0})),{throwOnTimeout:!0})}callWithOptions(e,t,...r){return e.signal?Promise.race([this.call(t,...r),new Promise(((t,r)=>{e.signal?.addEventListener("abort",(()=>{r(new Error("AbortError"))}))}))]):this.call(t,...r)}fetch(...e){return this.call((()=>fetch(...e).then((e=>e.ok?e:Promise.reject(e)))))}}function D(e){return"function"==typeof e?._getType}function U(e){const t={type:e._getType(),data:{content:e.content}};return e?.additional_kwargs&&Object.keys(e.additional_kwargs).length>0&&(t.data.additional_kwargs={...e.additional_kwargs}),t}const H=()=>"undefined"!=typeof Deno;let B,F;async function q(){if(void 0===B){const e=(()=>{let e;return e="undefined"!=typeof window&&void 0!==window.document?"browser":"undefined"==typeof process||void 0===process.versions||void 0===process.versions.node||H()?"object"==typeof globalThis&&globalThis.constructor&&"DedicatedWorkerGlobalScope"===globalThis.constructor.name?"webworker":"undefined"!=typeof window&&"nodejs"===window.name||"undefined"!=typeof navigator&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom"))?"jsdom":H()?"deno":"other":"node",e})(),t=function(){if(void 0!==F)return F;const e=["VERCEL_GIT_COMMIT_SHA","NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA","COMMIT_REF","RENDER_GIT_COMMIT","CI_COMMIT_SHA","CIRCLE_SHA1","CF_PAGES_COMMIT_SHA","REACT_APP_GIT_SHA","SOURCE_VERSION","GITHUB_SHA","TRAVIS_COMMIT","GIT_COMMIT","BUILD_VCS_NUMBER","bamboo_planRepository_revision","Build.SourceVersion","BITBUCKET_COMMIT","DRONE_COMMIT_SHA","SEMAPHORE_GIT_SHA","BUILDKITE_COMMIT"],t={};for(const r of e){const e=z(r);void 0!==e&&(t[r]=e)}return F=t,t}();B={library:"langsmith",runtime:e,...t}}return B}function z(e){try{return"undefined"!=typeof process?process.env?.[e]:void 0}catch(e){return}}const G=e=>{const t=e.replace("http://","").replace("https://","").split("/")[0].split(":")[0];return"localhost"===t||"127.0.0.1"===t||"::1"===t},J=async(e,t)=>{const r=await e.text();if(!e.ok)throw new Error(`Failed to ${t}: ${e.status} ${e.statusText} ${r}`)};function V(e){if(void 0!==e)return e.trim().replace(/^"(.*)"$/,"$1").replace(/^'(.*)'$/,"$1")}function W(e){return"true"===z("LANGCHAIN_HIDE_INPUTS")?{}:e}function K(e){return"true"===z("LANGCHAIN_HIDE_OUTPUTS")?{}:e}function Q(e){if("string"!=typeof(t=e)||!j.test(t))throw new Error(`Invalid UUID: ${e}`);var t}class Y{constructor(e={}){Object.defineProperty(this,"apiKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"apiUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"webUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"caller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"timeout_ms",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_tenantId",{enumerable:!0,configurable:!0,writable:!0,value:null});const t=Y.getDefaultClientConfig();this.apiUrl=V(e.apiUrl??t.apiUrl)??"",this.apiKey=V(e.apiKey??t.apiKey),this.webUrl=V(e.webUrl??t.webUrl),this.validateApiKeyIfHosted(),this.timeout_ms=e.timeout_ms??4e3,this.caller=new M(e.callerOptions??{})}static getDefaultClientConfig(){const e=z("LANGCHAIN_API_KEY");return{apiUrl:z("LANGCHAIN_ENDPOINT")??(e?"https://api.smith.langchain.com":"http://localhost:1984"),apiKey:e,webUrl:void 0}}validateApiKeyIfHosted(){if(!G(this.apiUrl)&&!this.apiKey)throw new Error("API key must be provided when using hosted LangSmith API")}getHostUrl(){return this.webUrl?this.webUrl:G(this.apiUrl)?(this.webUrl="http://localhost","http://localhost"):this.apiUrl.includes("/api")?(this.webUrl=this.apiUrl.replace("/api",""),this.webUrl):this.apiUrl.split(".",1)[0].includes("dev")?(this.webUrl="https://dev.smith.langchain.com","https://dev.smith.langchain.com"):(this.webUrl="https://smith.langchain.com","https://smith.langchain.com")}get headers(){const e={};return this.apiKey&&(e["x-api-key"]=`${this.apiKey}`),e}async _getResponse(e,t){const r=t?.toString()??"",n=`${this.apiUrl}${e}?${r}`,a=await this.caller.call(fetch,n,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok)throw new Error(`Failed to fetch ${e}: ${a.status} ${a.statusText}`);return a}async _get(e,t){return(await this._getResponse(e,t)).json()}async*_getPaginated(e,t=new URLSearchParams){let r=Number(t.get("offset"))||0;const n=Number(t.get("limit"))||100;for(;;){t.set("offset",String(r)),t.set("limit",String(n));const a=`${this.apiUrl}${e}?${t}`,i=await this.caller.call(fetch,a,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!i.ok)throw new Error(`Failed to fetch ${e}: ${i.status} ${i.statusText}`);const s=await i.json();if(0===s.length)break;if(yield s,s.length<n)break;r+=s.length}}async*_getCursorPaginatedList(e,t=null,r="POST",n="runs"){let a=t?{...t}:{};for(;;){const t=await this.caller.call(fetch,`${this.apiUrl}${e}`,{method:r,headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),body:JSON.stringify(a)}),i=await t.json();if(!i)break;if(!i[n])break;yield i[n];const s=i.cursors;if(!s)break;if(!s.next)break;a.cursor=s.next}}async createRun(e){const t={...this.headers,"Content-Type":"application/json"},r=e.extra??{},n=await q(),a=e.project_name;delete e.project_name;const i={session_name:a,...e,extra:{...e.extra,runtime:{...n,...r.runtime}}};i.inputs=W(i.inputs),i.outputs&&(i.outputs=K(i.outputs));const s=await this.caller.call(fetch,`${this.apiUrl}/runs`,{method:"POST",headers:t,body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms)});await J(s,"create run")}async updateRun(e,t){Q(e),t.inputs&&(t.inputs=W(t.inputs)),t.outputs&&(t.outputs=K(t.outputs));const r={...this.headers,"Content-Type":"application/json"},n=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}`,{method:"PATCH",headers:r,body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms)});await J(n,"update run")}async readRun(e,{loadChildRuns:t}={loadChildRuns:!1}){Q(e);let r=await this._get(`/runs/${e}`);return t&&r.child_run_ids&&(r=await this._loadChildRuns(r)),r}async getRunUrl({runId:e,run:t,projectOpts:r}){if(void 0!==t){let e;e=t.session_id?t.session_id:r?.projectName?(await this.readProject({projectName:r?.projectName})).id:r?.projectId?r?.projectId:(await this.readProject({projectName:z("LANGCHAIN_PROJECT")||"default"})).id;const n=await this._getTenantId();return`${this.getHostUrl()}/o/${n}/projects/p/${e}/r/${t.id}?poll=true`}if(void 0!==e){const t=await this.readRun(e);if(!t.app_path)throw new Error(`Run ${e} has no app_path`);return`${this.getHostUrl()}${t.app_path}`}throw new Error("Must provide either runId or run")}async _loadChildRuns(e){const t=await async function(e){const t=[];for await(const r of e)t.push(r);return t}(this.listRuns({id:e.child_run_ids})),r={},n={};t.sort(((e,t)=>(e?.dotted_order??"").localeCompare(t?.dotted_order??"")));for(const e of t){if(null===e.parent_run_id||void 0===e.parent_run_id)throw new Error(`Child run ${e.id} has no parent`);e.parent_run_id in r||(r[e.parent_run_id]=[]),r[e.parent_run_id].push(e),n[e.id]=e}e.child_runs=r[e.id]||[];for(const t in r)t!==e.id&&(n[t].child_runs=r[t]);return e}async*listRuns({projectId:e,projectName:t,parentRunId:r,referenceExampleId:n,startTime:a,executionOrder:i,runType:s,error:o,id:l,query:c,filter:u,limit:h}){let d=e;if(t){if(e)throw new Error("Only one of projectId or projectName may be given");d=(await this.readProject({projectName:t})).id}const p={session:d?[d]:null,run_type:s,reference_example:n,query:c,filter:u,execution_order:i,parent_run:r?[r]:null,start_time:a?a.toISOString():null,error:o,id:l,limit:h};for await(const e of this._getCursorPaginatedList("/runs/query",p))yield*e}async shareRun(e,{shareId:t}={}){const r={run_id:e,share_token:t||$()};Q(e);const n=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(r),signal:AbortSignal.timeout(this.timeout_ms)}),a=await n.json();if(null===a||!("share_token"in a))throw new Error("Invalid response from server");return`${this.getHostUrl()}/public/${a.share_token}/r`}async unshareRun(e){Q(e);const t=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});await J(t,"unshare run")}async readRunSharedLink(e){Q(e);const t=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)}),r=await t.json();if(null!==r&&"share_token"in r)return`${this.getHostUrl()}/public/${r.share_token}/r`}async listSharedRuns(e,{runIds:t}={}){const r=new URLSearchParams({share_token:e});if(void 0!==t)for(const e of t)r.append("id",e);Q(e);const n=await this.caller.call(fetch,`${this.apiUrl}/public/${e}/runs${r}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});return await n.json()}async readDatasetSharedSchema(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id),Q(e);const r=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)}),n=await r.json();return n.url=`${this.getHostUrl()}/public/${n.share_token}/d`,n}async shareDataset(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id);const r={dataset_id:e};Q(e);const n=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(r),signal:AbortSignal.timeout(this.timeout_ms)}),a=await n.json();return a.url=`${this.getHostUrl()}/public/${a.share_token}/d`,a}async unshareDataset(e){Q(e);const t=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});await J(t,"unshare dataset")}async readSharedDataset(e){Q(e);const t=await this.caller.call(fetch,`${this.apiUrl}/public/${e}/datasets`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});return await t.json()}async createProject({projectName:e,description:t=null,metadata:r=null,upsert:n=!1,projectExtra:a=null,referenceDatasetId:i=null}){const s=n?"?upsert=true":"",o=`${this.apiUrl}/sessions${s}`,l=a||{};r&&(l.metadata=r);const c={name:e,extra:l,description:t};null!==i&&(c.reference_dataset_id=i);const u=await this.caller.call(fetch,o,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(c),signal:AbortSignal.timeout(this.timeout_ms)}),h=await u.json();if(!u.ok)throw new Error(`Failed to create session ${e}: ${u.status} ${u.statusText}`);return h}async updateProject(e,{name:t=null,description:r=null,metadata:n=null,projectExtra:a=null,endTime:i=null}){const s=`${this.apiUrl}/sessions/${e}`;let o=a;n&&(o={...o||{},metadata:n});const l={name:t,extra:o,description:r,end_time:i?new Date(i).toISOString():null},c=await this.caller.call(fetch,s,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(l),signal:AbortSignal.timeout(this.timeout_ms)}),u=await c.json();if(!c.ok)throw new Error(`Failed to update project ${e}: ${c.status} ${c.statusText}`);return u}async readProject({projectId:e,projectName:t}){let r="/sessions";const n=new URLSearchParams;if(void 0!==e&&void 0!==t)throw new Error("Must provide either projectName or projectId, not both");if(void 0!==e)Q(e),r+=`/${e}`;else{if(void 0===t)throw new Error("Must provide projectName or projectId");n.append("name",t)}const a=await this._get(r,n);let i;if(Array.isArray(a)){if(0===a.length)throw new Error(`Project[id=${e}, name=${t}] not found`);i=a[0]}else i=a;return i}async _getTenantId(){if(null!==this._tenantId)return this._tenantId;const e=new URLSearchParams({limit:"1"});for await(const t of this._getPaginated("/sessions",e))return this._tenantId=t[0].tenant_id,t[0].tenant_id;throw new Error("No projects found to resolve tenant.")}async*listProjects({projectIds:e,name:t,nameContains:r,referenceDatasetId:n,referenceDatasetName:a,referenceFree:i}={}){const s=new URLSearchParams;if(void 0!==e)for(const t of e)s.append("id",t);if(void 0!==t&&s.append("name",t),void 0!==r&&s.append("name_contains",r),void 0!==n)s.append("reference_dataset",n);else if(void 0!==a){const e=await this.readDataset({datasetName:a});s.append("reference_dataset",e.id)}void 0!==i&&s.append("reference_free",i.toString());for await(const e of this._getPaginated("/sessions",s))yield*e}async deleteProject({projectId:e,projectName:t}){let r;if(void 0===e&&void 0===t)throw new Error("Must provide projectName or projectId");if(void 0!==e&&void 0!==t)throw new Error("Must provide either projectName or projectId, not both");r=void 0===e?(await this.readProject({projectName:t})).id:e,Q(r);const n=await this.caller.call(fetch,`${this.apiUrl}/sessions/${r}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});await J(n,`delete session ${r} (${t})`)}async uploadCsv({csvFile:e,fileName:t,inputKeys:r,outputKeys:n,description:a,dataType:i,name:s}){const o=`${this.apiUrl}/datasets/upload`,l=new FormData;l.append("file",e,t),r.forEach((e=>{l.append("input_keys",e)})),n.forEach((e=>{l.append("output_keys",e)})),a&&l.append("description",a),i&&l.append("data_type",i),s&&l.append("name",s);const c=await this.caller.call(fetch,o,{method:"POST",headers:this.headers,body:l,signal:AbortSignal.timeout(this.timeout_ms)});if(!c.ok){const e=await c.json();if(e.detail&&e.detail.includes("already exists"))throw new Error(`Dataset ${t} already exists`);throw new Error(`Failed to upload CSV: ${c.status} ${c.statusText}`)}return await c.json()}async createDataset(e,{description:t,dataType:r}={}){const n={name:e,description:t};r&&(n.data_type=r);const a=await this.caller.call(fetch,`${this.apiUrl}/datasets`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(n),signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok){const t=await a.json();if(t.detail&&t.detail.includes("already exists"))throw new Error(`Dataset ${e} already exists`);throw new Error(`Failed to create dataset ${a.status} ${a.statusText}`)}return await a.json()}async readDataset({datasetId:e,datasetName:t}){let r="/datasets";const n=new URLSearchParams({limit:"1"});if(void 0!==e&&void 0!==t)throw new Error("Must provide either datasetName or datasetId, not both");if(void 0!==e)Q(e),r+=`/${e}`;else{if(void 0===t)throw new Error("Must provide datasetName or datasetId");n.append("name",t)}const a=await this._get(r,n);let i;if(Array.isArray(a)){if(0===a.length)throw new Error(`Dataset[id=${e}, name=${t}] not found`);i=a[0]}else i=a;return i}async readDatasetOpenaiFinetuning({datasetId:e,datasetName:t}){if(void 0!==e);else{if(void 0===t)throw new Error("Must provide datasetName or datasetId");e=(await this.readDataset({datasetName:t})).id}const r=await this._getResponse(`/datasets/${e}/openai_ft`);return(await r.text()).trim().split("\n").map((e=>JSON.parse(e)))}async*listDatasets({limit:e=100,offset:t=0,datasetIds:r,datasetName:n,datasetNameContains:a}={}){const i=new URLSearchParams({limit:e.toString(),offset:t.toString()});if(void 0!==r)for(const e of r)i.append("id",e);void 0!==n&&i.append("name",n),void 0!==a&&i.append("name_contains",a);for await(const e of this._getPaginated("/datasets",i))yield*e}async deleteDataset({datasetId:e,datasetName:t}){let r="/datasets",n=e;if(void 0!==e&&void 0!==t)throw new Error("Must provide either datasetName or datasetId, not both");if(void 0!==t&&(n=(await this.readDataset({datasetName:t})).id),void 0===n)throw new Error("Must provide datasetName or datasetId");Q(n),r+=`/${n}`;const a=await this.caller.call(fetch,this.apiUrl+r,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok)throw new Error(`Failed to delete ${r}: ${a.status} ${a.statusText}`);await a.json()}async createExample(e,t,{datasetId:r,datasetName:n,createdAt:a,exampleId:i}){let s=r;if(void 0===s&&void 0===n)throw new Error("Must provide either datasetName or datasetId");if(void 0!==s&&void 0!==n)throw new Error("Must provide either datasetName or datasetId, not both");void 0===s&&(s=(await this.readDataset({datasetName:n})).id);const o={dataset_id:s,inputs:e,outputs:t,created_at:(a||new Date).toISOString(),id:i},l=await this.caller.call(fetch,`${this.apiUrl}/examples`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(o),signal:AbortSignal.timeout(this.timeout_ms)});if(!l.ok)throw new Error(`Failed to create example: ${l.status} ${l.statusText}`);return await l.json()}async createLLMExample(e,t,r){return this.createExample({input:e},{output:t},r)}async createChatExample(e,t,r){const n=e.map((e=>D(e)?U(e):e)),a=D(t)?U(t):t;return this.createExample({input:n},{output:a},r)}async readExample(e){Q(e);const t=`/examples/${e}`;return await this._get(t)}async*listExamples({datasetId:e,datasetName:t,exampleIds:r}={}){let n;if(void 0!==e&&void 0!==t)throw new Error("Must provide either datasetName or datasetId, not both");if(void 0!==e)n=e;else{if(void 0===t)throw new Error("Must provide a datasetName or datasetId");n=(await this.readDataset({datasetName:t})).id}const a=new URLSearchParams({dataset:n});if(void 0!==r)for(const e of r)a.append("id",e);for await(const e of this._getPaginated("/examples",a))yield*e}async deleteExample(e){Q(e);const t=`/examples/${e}`,r=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!r.ok)throw new Error(`Failed to delete ${t}: ${r.status} ${r.statusText}`);await r.json()}async updateExample(e,t){Q(e);const r=await this.caller.call(fetch,`${this.apiUrl}/examples/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms)});if(!r.ok)throw new Error(`Failed to update example ${e}: ${r.status} ${r.statusText}`);return await r.json()}async evaluateRun(e,t,{sourceInfo:r,loadChildRuns:n}={loadChildRuns:!1}){let a,i;if("string"==typeof e)a=await this.readRun(e,{loadChildRuns:n});else{if("object"!=typeof e||!("id"in e))throw new Error("Invalid run type: "+typeof e);a=e}null!==a.reference_example_id&&void 0!==a.reference_example_id&&(i=await this.readExample(a.reference_example_id));const s=await t.evaluateRun(a,i);let o=r??{};return s.evaluatorInfo&&(o={...o,...s.evaluatorInfo}),await this.createFeedback(a.id,s.key,{score:s.score,value:s.value,comment:s.comment,correction:s.correction,sourceInfo:o,feedbackSourceType:"model"})}async createFeedback(e,t,{score:r,value:n,correction:a,comment:i,sourceInfo:s,feedbackSourceType:o="api",sourceRunId:l,feedbackId:c,eager:u=!1}){const h={type:o??"api",metadata:s??{}};void 0===l||void 0===h?.metadata||h.metadata.__run||(h.metadata.__run={run_id:l}),void 0!==h?.metadata&&void 0!==h.metadata.__run?.run_id&&Q(h.metadata.__run.run_id);const d={id:c??$(),run_id:e,key:t,score:r,value:n,correction:a,comment:i,feedback_source:h},p=`${this.apiUrl}/feedback`+(u?"/eager":""),f=await this.caller.call(fetch,p,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(d),signal:AbortSignal.timeout(this.timeout_ms)});return await J(f,"create feedback"),d}async updateFeedback(e,{score:t,value:r,correction:n,comment:a}){const i={};null!=t&&(i.score=t),null!=r&&(i.value=r),null!=n&&(i.correction=n),null!=a&&(i.comment=a),Q(e);const s=await this.caller.call(fetch,`${this.apiUrl}/feedback/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms)});await J(s,"update feedback")}async readFeedback(e){Q(e);const t=`/feedback/${e}`;return await this._get(t)}async deleteFeedback(e){Q(e);const t=`/feedback/${e}`,r=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!r.ok)throw new Error(`Failed to delete ${t}: ${r.status} ${r.statusText}`);await r.json()}async*listFeedback({runIds:e,feedbackKeys:t,feedbackSourceTypes:r}={}){const n=new URLSearchParams;if(e&&n.append("run",e.join(",")),t)for(const e of t)n.append("key",e);if(r)for(const e of r)n.append("source",e);for await(const e of this._getPaginated("/feedback",n))yield*e}}const Z=()=>"undefined"!=typeof Deno;let X,ee;async function te(){if(void 0===X){const e=(()=>{let e;return e="undefined"!=typeof window&&void 0!==window.document?"browser":"undefined"==typeof process||void 0===process.versions||void 0===process.versions.node||Z()?"object"==typeof globalThis&&globalThis.constructor&&"DedicatedWorkerGlobalScope"===globalThis.constructor.name?"webworker":"undefined"!=typeof window&&"nodejs"===window.name||"undefined"!=typeof navigator&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom"))?"jsdom":Z()?"deno":"other":"node",e})();X={library:"langchain-js",runtime:e}}return X}function re(e){try{return"undefined"!=typeof process?process.env?.[e]:void 0}catch(e){return}}class ne extends E{constructor(e={}){super(e),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"langchain_tracer"}),Object.defineProperty(this,"projectName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"exampleId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0});const{exampleId:t,projectName:r,client:n}=e;this.projectName=r??re("LANGCHAIN_PROJECT")??re("LANGCHAIN_SESSION"),this.exampleId=t,this.client=n??new Y({})}async _convertToCreate(e,t){return{...e,extra:{...e.extra,runtime:await te()},child_runs:void 0,session_name:this.projectName,reference_example_id:e.parent_run_id?void 0:t}}async persistRun(e){}async _persistRunSingle(e){const t=await this._convertToCreate(e,this.exampleId);await this.client.createRun(t)}async _updateRunSingle(e){const t={end_time:e.end_time,error:e.error,outputs:e.outputs,events:e.events,inputs:e.inputs};await this.client.updateRun(e.id,t)}async onRetrieverStart(e){await this._persistRunSingle(e)}async onRetrieverEnd(e){await this._updateRunSingle(e)}async onRetrieverError(e){await this._updateRunSingle(e)}async onLLMStart(e){await this._persistRunSingle(e)}async onLLMEnd(e){await this._updateRunSingle(e)}async onLLMError(e){await this._updateRunSingle(e)}async onChainStart(e){await this._persistRunSingle(e)}async onChainEnd(e){await this._updateRunSingle(e)}async onChainError(e){await this._updateRunSingle(e)}async onToolStart(e){await this._persistRunSingle(e)}async onToolEnd(e){await this._updateRunSingle(e)}async onToolError(e){await this._updateRunSingle(e)}}async function ae(e,t){!0===t?await e():(void 0===ee&&(ee=new(0,N.default)({autoStart:!0,concurrency:1})),ee.add(e))}class ie{constructor(e,t,r,n,a,i,s,o){Object.defineProperty(this,"runId",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"inheritableTags",{enumerable:!0,configurable:!0,writable:!0,value:a}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:i}),Object.defineProperty(this,"inheritableMetadata",{enumerable:!0,configurable:!0,writable:!0,value:s}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:o})}async handleText(e){await Promise.all(this.handlers.map((t=>ae((async()=>{try{await(t.handleText?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleText: ${e}`)}}),t.awaitHandlers))))}}class se extends ie{getChild(e){const t=new ue(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleRetrieverEnd(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreRetriever)try{await(t.handleRetrieverEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleRetriever`)}}),t.awaitHandlers))))}async handleRetrieverError(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreRetriever)try{await(t.handleRetrieverError?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleRetrieverError: ${e}`)}}),t.awaitHandlers))))}}class oe extends ie{async handleLLMNewToken(e,t,r,n,a,i){await Promise.all(this.handlers.map((r=>ae((async()=>{if(!r.ignoreLLM)try{await(r.handleLLMNewToken?.(e,t??{prompt:0,completion:0},this.runId,this._parentRunId,this.tags,i))}catch(e){console.error(`Error in handler ${r.constructor.name}, handleLLMNewToken: ${e}`)}}),r.awaitHandlers))))}async handleLLMError(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreLLM)try{await(t.handleLLMError?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleLLMError: ${e}`)}}),t.awaitHandlers))))}async handleLLMEnd(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreLLM)try{await(t.handleLLMEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleLLMEnd: ${e}`)}}),t.awaitHandlers))))}}class le extends ie{getChild(e){const t=new ue(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleChainError(e,t,r,n,a){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreChain)try{await(t.handleChainError?.(e,this.runId,this._parentRunId,this.tags,a))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleChainError: ${e}`)}}),t.awaitHandlers))))}async handleChainEnd(e,t,r,n,a){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreChain)try{await(t.handleChainEnd?.(e,this.runId,this._parentRunId,this.tags,a))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleChainEnd: ${e}`)}}),t.awaitHandlers))))}async handleAgentAction(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreAgent)try{await(t.handleAgentAction?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleAgentAction: ${e}`)}}),t.awaitHandlers))))}async handleAgentEnd(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreAgent)try{await(t.handleAgentEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleAgentEnd: ${e}`)}}),t.awaitHandlers))))}}class ce extends ie{getChild(e){const t=new ue(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleToolError(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreAgent)try{await(t.handleToolError?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleToolError: ${e}`)}}),t.awaitHandlers))))}async handleToolEnd(e){await Promise.all(this.handlers.map((t=>ae((async()=>{if(!t.ignoreAgent)try{await(t.handleToolEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleToolEnd: ${e}`)}}),t.awaitHandlers))))}}class ue extends class{setHandler(e){return this.setHandlers([e])}}{constructor(e,t){super(),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"inheritableTags",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"inheritableMetadata",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"callback_manager"}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.handlers=t?.handlers??this.handlers,this.inheritableHandlers=t?.inheritableHandlers??this.inheritableHandlers,this.tags=t?.tags??this.tags,this.inheritableTags=t?.inheritableTags??this.inheritableTags,this.metadata=t?.metadata??this.metadata,this.inheritableMetadata=t?.inheritableMetadata??this.inheritableMetadata,this._parentRunId=e}async handleLLMStart(e,t,r,n,a,i,s,o){return Promise.all(t.map((async t=>{const r=h();return await Promise.all(this.handlers.map((n=>ae((async()=>{if(!n.ignoreLLM)try{await(n.handleLLMStart?.(e,[t],r,this._parentRunId,a,this.tags,this.metadata,o))}catch(e){console.error(`Error in handler ${n.constructor.name}, handleLLMStart: ${e}`)}}),n.awaitHandlers)))),new oe(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)})))}async handleChatModelStart(e,t,r,n,a,i,s,o){return Promise.all(t.map((async t=>{const r=h();return await Promise.all(this.handlers.map((n=>ae((async()=>{if(!n.ignoreLLM)try{if(n.handleChatModelStart)await(n.handleChatModelStart?.(e,[t],r,this._parentRunId,a,this.tags,this.metadata,o));else if(n.handleLLMStart){const i=function(e,t="Human",r="AI"){const n=[];for(const a of e){let e;if("human"===a._getType())e=t;else if("ai"===a._getType())e=r;else if("system"===a._getType())e="System";else if("function"===a._getType())e="Function";else if("tool"===a._getType())e="Tool";else{if("generic"!==a._getType())throw new Error(`Got unsupported message type: ${a._getType()}`);e=a.role}const i=a.name?`${a.name}, `:"";n.push(`${e}: ${i}${a.content}`)}return n.join("\n")}(t);await(n.handleLLMStart?.(e,[i],r,this._parentRunId,a,this.tags,this.metadata,o))}}catch(e){console.error(`Error in handler ${n.constructor.name}, handleLLMStart: ${e}`)}}),n.awaitHandlers)))),new oe(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)})))}async handleChainStart(e,t,r=h(),n,a,i,s){return await Promise.all(this.handlers.map((a=>ae((async()=>{if(!a.ignoreChain)try{await(a.handleChainStart?.(e,t,r,this._parentRunId,this.tags,this.metadata,n,s))}catch(e){console.error(`Error in handler ${a.constructor.name}, handleChainStart: ${e}`)}}),a.awaitHandlers)))),new le(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}async handleToolStart(e,t,r=h(),n,a,i,s){return await Promise.all(this.handlers.map((n=>ae((async()=>{if(!n.ignoreAgent)try{await(n.handleToolStart?.(e,t,r,this._parentRunId,this.tags,this.metadata,s))}catch(e){console.error(`Error in handler ${n.constructor.name}, handleToolStart: ${e}`)}}),n.awaitHandlers)))),new ce(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}async handleRetrieverStart(e,t,r=h(),n,a,i,s){return await Promise.all(this.handlers.map((n=>ae((async()=>{if(!n.ignoreRetriever)try{await(n.handleRetrieverStart?.(e,t,r,this._parentRunId,this.tags,this.metadata,s))}catch(e){console.error(`Error in handler ${n.constructor.name}, handleRetrieverStart: ${e}`)}}),n.awaitHandlers)))),new se(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}addHandler(e,t=!0){this.handlers.push(e),t&&this.inheritableHandlers.push(e)}removeHandler(e){this.handlers=this.handlers.filter((t=>t!==e)),this.inheritableHandlers=this.inheritableHandlers.filter((t=>t!==e))}setHandlers(e,t=!0){this.handlers=[],this.inheritableHandlers=[];for(const r of e)this.addHandler(r,t)}addTags(e,t=!0){this.removeTags(e),this.tags.push(...e),t&&this.inheritableTags.push(...e)}removeTags(e){this.tags=this.tags.filter((t=>!e.includes(t))),this.inheritableTags=this.inheritableTags.filter((t=>!e.includes(t)))}addMetadata(e,t=!0){this.metadata={...this.metadata,...e},t&&(this.inheritableMetadata={...this.inheritableMetadata,...e})}removeMetadata(e){for(const t of Object.keys(e))delete this.metadata[t],delete this.inheritableMetadata[t]}copy(e=[],t=!0){const r=new ue(this._parentRunId);for(const e of this.handlers){const t=this.inheritableHandlers.includes(e);r.addHandler(e,t)}for(const e of this.tags){const t=this.inheritableTags.includes(e);r.addTags([e],t)}for(const e of Object.keys(this.metadata)){const t=Object.keys(this.inheritableMetadata).includes(e);r.addMetadata({[e]:this.metadata[e]},t)}for(const n of e)r.handlers.filter((e=>"console_callback_handler"===e.name)).some((e=>e.name===n.name))||r.addHandler(n,t);return r}static fromHandlers(e){const t=new this;return t.addHandler(new class extends y{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:h()}),Object.assign(this,e)}}),t}static async configure(e,t,r,n,a,i,s){let o;(e||t)&&(Array.isArray(e)||!e?(o=new ue,o.setHandlers(e?.map(he)??[],!0)):o=e,o=o.copy(Array.isArray(t)?t.map(he):t?.handlers,!1));const l="true"===re("LANGCHAIN_VERBOSE")||s?.verbose,c="true"===re("LANGCHAIN_TRACING_V2"),u=c||(re("LANGCHAIN_TRACING")??!1);if(l||u){if(o||(o=new ue),l&&!o.handlers.some((e=>e.name===A.prototype.name))){const e=new A;o.addHandler(e,!0)}u&&!o.handlers.some((e=>"langchain_tracer"===e.name))&&c&&o.addHandler(await async function(){return new ne}(),!0)}return(r||n)&&o&&(o.addTags(r??[]),o.addTags(n??[],!1)),(a||i)&&o&&(o.addMetadata(a??{}),o.addMetadata(i??{},!1)),o}}function he(e){return"name"in e?e:y.fromMethods(e)}const de=Object.prototype.hasOwnProperty;function pe(e,t){return de.call(e,t)}function fe(e){switch(typeof e){case"object":return JSON.parse(JSON.stringify(e));case"undefined":return null;default:return e}}function me(e){let t=0;const r=e.length;let n;for(;t<r;){if(n=e.charCodeAt(t),!(n>=48&&n<=57))return!1;t++}return!0}function ge(e){if(void 0===e)return!0;if(e)if(Array.isArray(e)){for(let t=0,r=e.length;t<r;t++)if(ge(e[t]))return!0}else if("object"==typeof e){const r=function(e){if(Array.isArray(e)){const t=new Array(e.length);for(let e=0;e<t.length;e++)t[e]=""+e;return t}if(Object.keys)return Object.keys(e);let t=[];for(let r in e)pe(e,r)&&t.push(r);return t}(e),n=r.length;for(var t=0;t<n;t++)if(ge(e[r[t]]))return!0}return!1}function be(e,t){const r=[e];for(const e in t){const n="object"==typeof t[e]?JSON.stringify(t[e],null,2):t[e];void 0!==n&&r.push(`${e}: ${n}`)}return r.join("\n")}class we extends Error{constructor(e,t,r,n,a){super(be(e,{name:t,index:r,operation:n,tree:a})),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"index",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"operation",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"tree",{enumerable:!0,configurable:!0,writable:!0,value:a}),Object.setPrototypeOf(this,new.target.prototype),this.message=be(e,{name:t,index:r,operation:n,tree:a})}}const ye=we,_e=fe,ve={add:function(e,t,r){return e[t]=this.value,{newDocument:r}},remove:function(e,t,r){var n=e[t];return delete e[t],{newDocument:r,removed:n}},replace:function(e,t,r){var n=e[t];return e[t]=this.value,{newDocument:r,removed:n}},move:function(e,t,r){let n=Oe(r,this.path);n&&(n=fe(n));const a=Te(r,{op:"remove",path:this.from}).removed;return Te(r,{op:"add",path:this.path,value:a}),{newDocument:r,removed:n}},copy:function(e,t,r){const n=Oe(r,this.from);return Te(r,{op:"add",path:this.path,value:fe(n)}),{newDocument:r}},test:function(e,t,r){return{newDocument:r,test:xe(e[t],this.value)}},_get:function(e,t,r){return this.value=e[t],{newDocument:r}}};var Ee={add:function(e,t,r){return me(t)?e.splice(t,0,this.value):e[t]=this.value,{newDocument:r,index:t}},remove:function(e,t,r){return{newDocument:r,removed:e.splice(t,1)[0]}},replace:function(e,t,r){var n=e[t];return e[t]=this.value,{newDocument:r,removed:n}},move:ve.move,copy:ve.copy,test:ve.test,_get:ve._get};function Oe(e,t){if(""==t)return e;var r={op:"_get",path:t};return Te(e,r),r.value}function Te(e,t,r=!1,n=!0,a=!0,i=0){if(r&&("function"==typeof r?r(t,0,e,t.path):Ae(t,0)),""===t.path){let n={newDocument:e};if("add"===t.op)return n.newDocument=t.value,n;if("replace"===t.op)return n.newDocument=t.value,n.removed=e,n;if("move"===t.op||"copy"===t.op)return n.newDocument=Oe(e,t.from),"move"===t.op&&(n.removed=e),n;if("test"===t.op){if(n.test=xe(e,t.value),!1===n.test)throw new ye("Test operation failed","TEST_OPERATION_FAILED",i,t,e);return n.newDocument=e,n}if("remove"===t.op)return n.removed=e,n.newDocument=null,n;if("_get"===t.op)return t.value=e,n;if(r)throw new ye("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",i,t,e);return n}{n||(e=fe(e));const s=(t.path||"").split("/");let o,l,c,u=e,h=1,d=s.length;for(c="function"==typeof r?r:Ae;;){if(l=s[h],l&&-1!=l.indexOf("~")&&(l=l.replace(/~1/g,"/").replace(/~0/g,"~")),a&&("__proto__"==l||"prototype"==l&&h>0&&"constructor"==s[h-1]))throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");if(r&&void 0===o&&(void 0===u[l]?o=s.slice(0,h).join("/"):h==d-1&&(o=t.path),void 0!==o&&c(t,0,e,o)),h++,Array.isArray(u)){if("-"===l)l=u.length;else{if(r&&!me(l))throw new ye("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index","OPERATION_PATH_ILLEGAL_ARRAY_INDEX",i,t,e);me(l)&&(l=~~l)}if(h>=d){if(r&&"add"===t.op&&l>u.length)throw new ye("The specified index MUST NOT be greater than the number of elements in the array","OPERATION_VALUE_OUT_OF_BOUNDS",i,t,e);const n=Ee[t.op].call(t,u,l,e);if(!1===n.test)throw new ye("Test operation failed","TEST_OPERATION_FAILED",i,t,e);return n}}else if(h>=d){const r=ve[t.op].call(t,u,l,e);if(!1===r.test)throw new ye("Test operation failed","TEST_OPERATION_FAILED",i,t,e);return r}if(u=u[l],r&&h<d&&(!u||"object"!=typeof u))throw new ye("Cannot perform operation at the desired path","OPERATION_PATH_UNRESOLVABLE",i,t,e)}}}function Se(e,t,r,n=!0,a=!0){if(r&&!Array.isArray(t))throw new ye("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");n||(e=fe(e));const i=new Array(t.length);for(let n=0,s=t.length;n<s;n++)i[n]=Te(e,t[n],r,!0,a,n),e=i[n].newDocument;return i.newDocument=e,i}function Ce(e,t,r){const n=Te(e,t);if(!1===n.test)throw new ye("Test operation failed","TEST_OPERATION_FAILED",r,t,e);return n.newDocument}function Ae(e,t,r,n){if("object"!=typeof e||null===e||Array.isArray(e))throw new ye("Operation is not an object","OPERATION_NOT_AN_OBJECT",t,e,r);if(!ve[e.op])throw new ye("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",t,e,r);if("string"!=typeof e.path)throw new ye("Operation `path` property is not a string","OPERATION_PATH_INVALID",t,e,r);if(0!==e.path.indexOf("/")&&e.path.length>0)throw new ye('Operation `path` property must start with "/"',"OPERATION_PATH_INVALID",t,e,r);if(("move"===e.op||"copy"===e.op)&&"string"!=typeof e.from)throw new ye("Operation `from` property is not present (applicable in `move` and `copy` operations)","OPERATION_FROM_REQUIRED",t,e,r);if(("add"===e.op||"replace"===e.op||"test"===e.op)&&void 0===e.value)throw new ye("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_REQUIRED",t,e,r);if(("add"===e.op||"replace"===e.op||"test"===e.op)&&ge(e.value))throw new ye("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED",t,e,r);if(r)if("add"==e.op){var a=e.path.split("/").length,i=n.split("/").length;if(a!==i+1&&a!==i)throw new ye("Cannot perform an `add` operation at the desired path","OPERATION_PATH_CANNOT_ADD",t,e,r)}else if("replace"===e.op||"remove"===e.op||"_get"===e.op){if(e.path!==n)throw new ye("Cannot perform the operation at a path that does not exist","OPERATION_PATH_UNRESOLVABLE",t,e,r)}else if("move"===e.op||"copy"===e.op){var s=je([{op:"_get",path:e.from,value:void 0}],r);if(s&&"OPERATION_PATH_UNRESOLVABLE"===s.name)throw new ye("Cannot perform the operation from a path that does not exist","OPERATION_FROM_UNRESOLVABLE",t,e,r)}}function je(e,t,r){try{if(!Array.isArray(e))throw new ye("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");if(t)Se(fe(t),fe(e),r||!0);else{r=r||Ae;for(var n=0;n<e.length;n++)r(e[n],n,t,void 0)}}catch(e){if(e instanceof ye)return e;throw e}}function xe(e,t){if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t){var r,n,a,i=Array.isArray(e),s=Array.isArray(t);if(i&&s){if((n=e.length)!=t.length)return!1;for(r=n;0!=r--;)if(!xe(e[r],t[r]))return!1;return!0}if(i!=s)return!1;var o=Object.keys(e);if((n=o.length)!==Object.keys(t).length)return!1;for(r=n;0!=r--;)if(!t.hasOwnProperty(o[r]))return!1;for(r=n;0!=r--;)if(!xe(e[a=o[r]],t[a]))return!1;return!0}return e!=e&&t!=t}new WeakMap;class Ie extends ReadableStream{constructor(){super(...arguments),Object.defineProperty(this,"reader",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}ensureReader(){this.reader||(this.reader=this.getReader())}async next(){this.ensureReader();try{const e=await this.reader.read();return e.done?(this.reader.releaseLock(),{done:!0,value:void 0}):{done:!1,value:e.value}}catch(e){throw this.reader.releaseLock(),e}}async return(){if(this.ensureReader(),this.locked){const e=this.reader.cancel();this.reader.releaseLock(),await e}return{done:!0,value:void 0}}async throw(e){if(this.ensureReader(),this.locked){const e=this.reader.cancel();this.reader.releaseLock(),await e}throw e}[Symbol.asyncIterator](){return this}static fromReadableStream(e){const t=e.getReader();return new Ie({start:e=>function r(){return t.read().then((({done:t,value:n})=>{if(!t)return e.enqueue(n),r();e.close()}))}(),cancel(){t.releaseLock()}})}static fromAsyncGenerator(e){return new Ie({async pull(t){const{value:r,done:n}=await e.next();n&&t.close(),t.enqueue(r)}})}}function ke(e,t=2){const r=Array.from({length:t},(()=>[]));return r.map((async function*(t){for(;;)if(0===t.length){const t=await e.next();for(const e of r)e.push(t)}else{if(t[0].done)return;yield t.shift().value}}))}function Pe(e,t){if(Array.isArray(e)&&Array.isArray(t))return e.concat(t);if("string"==typeof e&&"string"==typeof t)return e+t;if("number"==typeof e&&"number"==typeof t)return e+t;if("concat"in e&&"function"==typeof e.concat)return e.concat(t);if("object"==typeof e&&"object"==typeof t){const r={...e};for(const[e,n]of Object.entries(t))r[e]=e in r?Pe(r[e],n):n;return r}throw new Error(`Cannot concat ${typeof e} and ${typeof t}`)}class Re{constructor(e,t){Object.defineProperty(this,"generator",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"setup",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"firstResult",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"firstResultUsed",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.generator=e,this.setup=new Promise(((r,n)=>{this.firstResult=e.next(),this.firstResult.then(t).then(r,n)}))}async next(...e){return this.firstResultUsed?this.generator.next(...e):(this.firstResultUsed=!0,this.firstResult)}async return(e){return this.generator.return(e)}async throw(e){return this.generator.throw(e)}[Symbol.asyncIterator](){return this}}class $e{constructor(e){Object.defineProperty(this,"ops",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.ops=e.ops}concat(e){const t=this.ops.concat(e.ops),r=Se({},t);return new Ne({ops:t,state:r[r.length-1].newDocument})}}class Ne extends $e{constructor(e){super(e),Object.defineProperty(this,"state",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.state=e.state}concat(e){const t=this.ops.concat(e.ops),r=Se(this.state,e.ops);return new Ne({ops:t,state:r[r.length-1].newDocument})}}class Le extends E{constructor(e){super(e),Object.defineProperty(this,"autoClose",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"includeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"keyMapByRunId",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"counterMapByRunName",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"transformStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"writer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"receiveStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"log_stream_tracer"}),this.autoClose=e?.autoClose??!0,this.includeNames=e?.includeNames,this.includeTypes=e?.includeTypes,this.includeTags=e?.includeTags,this.excludeNames=e?.excludeNames,this.excludeTypes=e?.excludeTypes,this.excludeTags=e?.excludeTags,this.transformStream=new TransformStream,this.writer=this.transformStream.writable.getWriter(),this.receiveStream=Ie.fromReadableStream(this.transformStream.readable)}[Symbol.asyncIterator](){return this.receiveStream}async persistRun(e){}_includeRun(e){if(void 0===e.parent_run_id)return!1;const t=e.tags??[];let r=void 0===this.includeNames&&void 0===this.includeTags&&void 0===this.includeTypes;return void 0!==this.includeNames&&(r=r||this.includeNames.includes(e.name)),void 0!==this.includeTypes&&(r=r||this.includeTypes.includes(e.run_type)),void 0!==this.includeTags&&(r=r||void 0!==t.find((e=>this.includeTags?.includes(e)))),void 0!==this.excludeNames&&(r=r&&!this.excludeNames.includes(e.name)),void 0!==this.excludeTypes&&(r=r&&!this.excludeTypes.includes(e.run_type)),void 0!==this.excludeTags&&(r=r&&t.every((e=>!this.excludeTags?.includes(e)))),r}async onRunCreate(e){if(void 0===e.parent_run_id&&await this.writer.write(new $e({ops:[{op:"replace",path:"",value:{id:e.id,streamed_output:[],final_output:void 0,logs:{}}}]})),!this._includeRun(e))return;void 0===this.counterMapByRunName[e.name]&&(this.counterMapByRunName[e.name]=0),this.counterMapByRunName[e.name]+=1;const t=this.counterMapByRunName[e.name];this.keyMapByRunId[e.id]=1===t?e.name:`${e.name}:${t}`;const r={id:e.id,name:e.name,type:e.run_type,tags:e.tags??[],metadata:e.extra?.metadata??{},start_time:new Date(e.start_time).toISOString(),streamed_output_str:[],final_output:void 0,end_time:void 0};await this.writer.write(new $e({ops:[{op:"add",path:`/logs/${this.keyMapByRunId[e.id]}`,value:r}]}))}async onRunUpdate(e){try{const t=this.keyMapByRunId[e.id];if(void 0===t)return;const r=[{op:"add",path:`/logs/${t}/final_output`,value:e.outputs}];void 0!==e.end_time&&r.push({op:"add",path:`/logs/${t}/end_time`,value:new Date(e.end_time).toISOString()});const n=new $e({ops:r});await this.writer.write(n)}finally{if(void 0===e.parent_run_id){const t=new $e({ops:[{op:"replace",path:"/final_output",value:e.outputs}]});await this.writer.write(t),this.autoClose&&await this.writer.close()}}}async onLLMNewToken(e,t){const r=this.keyMapByRunId[e.id];if(void 0===r)return;const n=new $e({ops:[{op:"add",path:`/logs/${r}/streamed_output_str/-`,value:t}]});await this.writer.write(n)}}async function Me(e){return ue.configure(e?.callbacks,void 0,e?.tags,void 0,e?.metadata)}function De(e,t){const r={...e};if(t)for(const n of Object.keys(t))if("metadata"===n)r[n]={...r[n],...t[n]};else if("tags"===n)r[n]=(r[n]??[]).concat(t[n]??[]);else if("configurable"===n)r[n]={...r[n],...t[n]};else if("callbacks"===n){const n=r.callbacks,a=t.callbacks??e.callbacks;if(Array.isArray(a))if(n)if(Array.isArray(n))r.callbacks=n.concat(a);else{const e=n.copy();for(const t of a)e.addHandler(t,!0);r.callbacks=e}else r.callbacks=a;else if(a)if(n)if(Array.isArray(n)){const e=a.copy();for(const t of n)e.addHandler(t,!0);r.callbacks=e}else r.callbacks=new ue(a.parentRunId,{handlers:n.handlers.concat(a.handlers),inheritableHandlers:n.inheritableHandlers.concat(a.inheritableHandlers),tags:Array.from(new Set(n.tags.concat(a.tags))),inheritableTags:Array.from(new Set(n.inheritableTags.concat(a.inheritableTags))),metadata:{...n.metadata,...a.metadata}});else r.callbacks=a}else r[n]=t[n]??r[n];return r}const Ue=[400,401,402,403,404,405,406,407,408,409],He=e=>{if(e.message.startsWith("Cancel")||e.message.startsWith("TimeoutError")||"TimeoutError"===e.name||e.message.startsWith("AbortError")||"AbortError"===e.name)throw e;if("ECONNABORTED"===e?.code)throw e;const t=e?.response?.status??e?.status;if(t&&Ue.includes(+t))throw e;if("insufficient_quota"===e?.error?.code){const t=new Error(e?.message);throw t.name="InsufficientQuotaError",t}};class Be{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"onFailedAttempt",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6,this.onFailedAttempt=e.onFailedAttempt??He;const t=N.default;this.queue=new t({concurrency:this.maxConcurrency})}call(e,...t){return this.queue.add((()=>i((()=>e(...t).catch((e=>{throw e instanceof Error?e:new Error(e)}))),{onFailedAttempt:this.onFailedAttempt,retries:this.maxRetries,randomize:!0})),{throwOnTimeout:!0})}callWithOptions(e,t,...r){return e.signal?Promise.race([this.call(t,...r),new Promise(((t,r)=>{e.signal?.addEventListener("abort",(()=>{r(new Error("AbortError"))}))}))]):this.call(t,...r)}fetch(...e){return this.call((()=>fetch(...e).then((e=>e.ok?e:Promise.reject(e)))))}}class Fe extends E{constructor({config:e,onStart:t,onEnd:r,onError:n}){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"RootListenersTracer"}),Object.defineProperty(this,"rootId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"argOnStart",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"argOnEnd",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"argOnError",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.config=e,this.argOnStart=t,this.argOnEnd=r,this.argOnError=n}persistRun(e){return Promise.resolve()}async onRunCreate(e){this.rootId||(this.rootId=e.id,this.argOnStart&&(1===this.argOnStart.length?await this.argOnStart(e):2===this.argOnStart.length&&await this.argOnStart(e,this.config)))}async onRunUpdate(e){e.id===this.rootId&&(e.error?this.argOnError&&(1===this.argOnError.length?await this.argOnError(e):2===this.argOnError.length&&await this.argOnError(e,this.config)):this.argOnEnd&&(1===this.argOnEnd.length?await this.argOnEnd(e):2===this.argOnEnd.length&&await this.argOnEnd(e,this.config)))}}function qe(e,t){return!e||Array.isArray(e)||e instanceof Date||"object"!=typeof e?{[t]:e}:e}class ze extends w{constructor(){super(...arguments),Object.defineProperty(this,"lc_runnable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}getName(e){const t=this.name??this.constructor.lc_name()??this.constructor.name;return e?`${t}${e}`:t}bind(e){return new Ge({bound:this,kwargs:e,config:{}})}map(){return new Je({bound:this})}withRetry(e){return new Ve({bound:this,kwargs:{},config:{},maxAttemptNumber:e?.stopAfterAttempt,...e})}withConfig(e){return new Ge({bound:this,config:e,kwargs:{}})}withFallbacks(e){return new Ye({runnable:this,fallbacks:e.fallbacks})}_getOptionsList(e,t=0){if(Array.isArray(e)){if(e.length!==t)throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${t} inputs`);return e}return Array.from({length:t},(()=>e))}async batch(e,t,r){const n=this._getOptionsList(t??{},e.length),a=new Be({maxConcurrency:r?.maxConcurrency,onFailedAttempt:e=>{throw e}}),i=e.map(((e,t)=>a.call((async()=>{try{return await this.invoke(e,n[t])}catch(e){if(r?.returnExceptions)return e;throw e}}))));return Promise.all(i)}async*_streamIterator(e,t){yield this.invoke(e,t)}async stream(e,t){return Ie.fromAsyncGenerator(this._streamIterator(e,t))}_separateRunnableConfigFromCallOptions(e={}){const t={callbacks:e.callbacks,tags:e.tags,metadata:e.metadata,runName:e.runName,configurable:e.configurable},r={...e};return delete r.callbacks,delete r.tags,delete r.metadata,delete r.runName,delete r.configurable,[t,r]}async _callWithConfig(e,t,r){const n=await Me(r),a=await(n?.handleChainStart(this.toJSON(),qe(t,"input"),void 0,r?.runType,void 0,void 0,r?.runName??this.getName()));let i;try{i=await e.bind(this)(t,r,a)}catch(e){throw await(a?.handleChainError(e)),e}return await(a?.handleChainEnd(qe(i,"output"))),i}async _batchWithConfig(e,t,r,n){const a=this._getOptionsList(r??{},t.length),i=await Promise.all(a.map(Me)),s=await Promise.all(i.map(((e,r)=>e?.handleChainStart(this.toJSON(),qe(t[r],"input"),void 0,a[r].runType,void 0,void 0,a[r].runName??this.getName()))));let o;try{o=await e(t,a,s,n)}catch(e){throw await Promise.all(s.map((t=>t?.handleChainError(e)))),e}return await Promise.all(s.map((e=>e?.handleChainEnd(qe(o,"output"))))),o}async*_transformStreamWithConfig(e,t,r){let n,a,i=!0,s=!0;const o=await Me(r);let l;try{const c=await async function(e,t,r,...n){const a=new Re(t,r),i=await a.setup;return{output:e(a,i,...n),setup:i}}(t,async function*(){for await(const t of e){if(i)if(void 0===n)n=t;else try{n=Pe(n,t)}catch{n=void 0,i=!1}yield t}}(),(async()=>o?.handleChainStart(this.toJSON(),{input:""},void 0,r?.runType,void 0,void 0,r?.runName??this.getName())),r);l=c.setup;for await(const e of c.output)if(yield e,s)if(void 0===a)a=e;else try{a=Pe(a,e)}catch{a=void 0,s=!1}}catch(e){throw await(l?.handleChainError(e,void 0,void 0,void 0,{inputs:qe(n,"input")})),e}await(l?.handleChainEnd(a??{},void 0,void 0,void 0,{inputs:qe(n,"input")}))}_patchConfig(e={},t,r){const n={...e};return void 0!==t?(delete n.runName,{...n,callbacks:t}):(void 0!==r&&(n.recursionLimit=r),n)}pipe(e){return new We({first:this,last:Ze(e)})}pick(e){return this.pipe(new et(e))}assign(e){return this.pipe(new Xe(new Ke({steps:e})))}async*transform(e,t){let r;for await(const t of e)r=void 0===r?t:Pe(r,t);yield*this._streamIterator(r,t)}async*streamLog(e,t,r){const n=new Le({...r,autoClose:!1}),a=t??{},{callbacks:i}=a;if(void 0===i)a.callbacks=[n];else if(Array.isArray(i))a.callbacks=i.concat([n]);else{const e=i.copy();e.inheritableHandlers.push(n),a.callbacks=e}const s=await this.stream(e,a),o=async function(){try{for await(const e of s){const t=new $e({ops:[{op:"add",path:"/streamed_output/-",value:e}]});await n.writer.write(t)}}finally{await n.writer.close()}}();try{for await(const e of n)yield e}finally{await o}}static isRunnable(e){return!!e&&e.lc_runnable}withListeners({onStart:e,onEnd:t,onError:r}){return new Ge({bound:this,config:{},configFactories:[n=>({callbacks:[new Fe({config:n,onStart:e,onEnd:t,onError:r})]})]})}}class Ge extends ze{static lc_name(){return"RunnableBinding"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"bound",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"configFactories",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.bound=e.bound,this.kwargs=e.kwargs,this.config=e.config,this.configFactories=e.configFactories}getName(e){return this.bound.getName(e)}async _mergeConfig(e){const t=De(this.config,e);return De(t,...this.configFactories?await Promise.all(this.configFactories.map((async e=>await e(t)))):[])}bind(e){return new this.constructor({bound:this.bound,kwargs:{...this.kwargs,...e},config:this.config})}withConfig(e){return new this.constructor({bound:this.bound,kwargs:this.kwargs,config:{...this.config,...e}})}withRetry(e){return new this.constructor({bound:this.bound.withRetry(e),kwargs:this.kwargs,config:this.config})}async invoke(e,t){return this.bound.invoke(e,await this._mergeConfig({...t,...this.kwargs}))}async batch(e,t,r){const n=Array.isArray(t)?await Promise.all(t.map((async e=>this._mergeConfig({...e,...this.kwargs})))):await this._mergeConfig({...t,...this.kwargs});return this.bound.batch(e,n,r)}async*_streamIterator(e,t){yield*this.bound._streamIterator(e,await this._mergeConfig({...t,...this.kwargs}))}async stream(e,t){return this.bound.stream(e,await this._mergeConfig({...t,...this.kwargs}))}async*transform(e,t){yield*this.bound.transform(e,await this._mergeConfig({...t,...this.kwargs}))}static isRunnableBinding(e){return e.bound&&ze.isRunnable(e.bound)}withListeners({onStart:e,onEnd:t,onError:r}){return new Ge({bound:this.bound,kwargs:this.kwargs,config:this.config,configFactories:[n=>({callbacks:[new Fe({config:n,onStart:e,onEnd:t,onError:r})]})]})}}class Je extends ze{static lc_name(){return"RunnableEach"}constructor(e){super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"bound",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.bound=e.bound}bind(e){return new Je({bound:this.bound.bind(e)})}async invoke(e,t){return this._callWithConfig(this._invoke,e,t)}async _invoke(e,t,r){return this.bound.batch(e,this._patchConfig(t,r?.getChild()))}withListeners({onStart:e,onEnd:t,onError:r}){return new Je({bound:this.bound.withListeners({onStart:e,onEnd:t,onError:r})})}}class Ve extends Ge{static lc_name(){return"RunnableRetry"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"maxAttemptNumber",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(this,"onFailedAttempt",{enumerable:!0,configurable:!0,writable:!0,value:()=>{}}),this.maxAttemptNumber=e.maxAttemptNumber??this.maxAttemptNumber,this.onFailedAttempt=e.onFailedAttempt??this.onFailedAttempt}_patchConfigForRetry(e,t,r){const n=e>1?`retry:attempt:${e}`:void 0;return this._patchConfig(t,r?.getChild(n))}async _invoke(e,t,r){return i((n=>super.invoke(e,this._patchConfigForRetry(n,t,r))),{onFailedAttempt:this.onFailedAttempt,retries:Math.max(this.maxAttemptNumber-1,0),randomize:!0})}async invoke(e,t){return this._callWithConfig(this._invoke,e,t)}async _batch(e,t,r,n){const a={};try{await i((async i=>{const s=e.map(((e,t)=>t)).filter((e=>void 0===a[e.toString()]||a[e.toString()]instanceof Error)),o=s.map((t=>e[t])),l=s.map((e=>this._patchConfigForRetry(i,t?.[e],r?.[e]))),c=await super.batch(o,l,{...n,returnExceptions:!0});let u;for(let e=0;e<c.length;e+=1){const t=c[e],r=s[e];t instanceof Error&&void 0===u&&(u=t),a[r.toString()]=t}if(u)throw u;return c}),{onFailedAttempt:this.onFailedAttempt,retries:Math.max(this.maxAttemptNumber-1,0),randomize:!0})}catch(e){if(!0!==n?.returnExceptions)throw e}return Object.keys(a).sort(((e,t)=>parseInt(e,10)-parseInt(t,10))).map((e=>a[parseInt(e,10)]))}async batch(e,t,r){return this._batchWithConfig(this._batch.bind(this),e,t,r)}}class We extends ze{static lc_name(){return"RunnableSequence"}constructor(e){super(e),Object.defineProperty(this,"first",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"middle",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"last",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),this.first=e.first,this.middle=e.middle??this.middle,this.last=e.last,this.name=e.name}get steps(){return[this.first,...this.middle,this.last]}async invoke(e,t){const r=await Me(t),n=await(r?.handleChainStart(this.toJSON(),qe(e,"input"),void 0,void 0,void 0,void 0,t?.runName));let a,i=e;try{const e=[this.first,...this.middle];for(let r=0;r<e.length;r+=1){const a=e[r];i=await a.invoke(i,this._patchConfig(t,n?.getChild(`seq:step:${r+1}`)))}a=await this.last.invoke(i,this._patchConfig(t,n?.getChild(`seq:step:${this.steps.length}`)))}catch(e){throw await(n?.handleChainError(e)),e}return await(n?.handleChainEnd(qe(a,"output"))),a}async batch(e,t,r){const n=this._getOptionsList(t??{},e.length),a=await Promise.all(n.map(Me)),i=await Promise.all(a.map(((t,r)=>t?.handleChainStart(this.toJSON(),qe(e[r],"input"),void 0,void 0,void 0,void 0,n[r].runName))));let s,o=e;try{const e=[this.first,...this.middle];for(let t=0;t<e.length;t+=1){const a=e[t];o=await a.batch(o,i.map(((e,r)=>this._patchConfig(n[r],e?.getChild(`seq:step:${t+1}`)))),r)}s=await this.last.batch(o,i.map((e=>this._patchConfig(n[this.steps.length-1],e?.getChild(`seq:step:${this.steps.length}`)))),r)}catch(e){throw await Promise.all(i.map((t=>t?.handleChainError(e)))),e}return await Promise.all(i.map(((e,t)=>e?.handleChainEnd(qe(s[t],"output"))))),s}async*_streamIterator(e,t){const r=await Me(t),n=await(r?.handleChainStart(this.toJSON(),qe(e,"input"),void 0,void 0,void 0,void 0,t?.runName)),a=[this.first,...this.middle,this.last];let i,s=!0;try{let r=a[0].transform(async function*(){yield e}(),this._patchConfig(t,n?.getChild("seq:step:1")));for(let e=1;e<a.length;e+=1){const i=a[e];r=await i.transform(r,this._patchConfig(t,n?.getChild(`seq:step:${e+1}`)))}for await(const e of r)if(yield e,s)if(void 0===i)i=e;else try{i=Pe(i,e)}catch(e){i=void 0,s=!1}}catch(e){throw await(n?.handleChainError(e)),e}await(n?.handleChainEnd(qe(i,"output")))}pipe(e){return We.isRunnableSequence(e)?new We({first:this.first,middle:this.middle.concat([this.last,e.first,...e.middle]),last:e.last,name:this.name??e.name}):new We({first:this.first,middle:[...this.middle,this.last],last:Ze(e),name:this.name})}static isRunnableSequence(e){return Array.isArray(e.middle)&&ze.isRunnable(e)}static from([e,...t],r){return new We({first:Ze(e),middle:t.slice(0,-1).map(Ze),last:Ze(t[t.length-1]),name:r})}}class Ke extends ze{static lc_name(){return"RunnableMap"}getStepsKeys(){return Object.keys(this.steps)}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"steps",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.steps={};for(const[t,r]of Object.entries(e.steps))this.steps[t]=Ze(r)}static from(e){return new Ke({steps:e})}async invoke(e,t){const r=await Me(t),n=await(r?.handleChainStart(this.toJSON(),{input:e},void 0,void 0,void 0,void 0,t?.runName)),a={};try{await Promise.all(Object.entries(this.steps).map((async([r,i])=>{a[r]=await i.invoke(e,this._patchConfig(t,n?.getChild(`map:key:${r}`)))})))}catch(e){throw await(n?.handleChainError(e)),e}return await(n?.handleChainEnd(a)),a}async*_transform(e,t,r){const n={...this.steps},a=ke(e,Object.keys(n).length),i=new Map(Object.entries(n).map((([e,n],i)=>{const s=n.transform(a[i],this._patchConfig(r,t?.getChild(`map:key:${e}`)));return[e,s.next().then((t=>({key:e,gen:s,result:t})))]})));for(;i.size;){const{key:e,result:t,gen:r}=await Promise.race(i.values());i.delete(e),t.done||(yield{[e]:t.value},i.set(e,r.next().then((t=>({key:e,gen:r,result:t})))))}}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){return Ie.fromAsyncGenerator(this.transform(async function*(){yield e}(),t))}}class Qe extends ze{static lc_name(){return"RunnableLambda"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"func",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.func=e.func}static from(e){return new Qe({func:e})}async _invoke(e,t,r){let n=await this.func(e,{config:t});if(n&&ze.isRunnable(n)){if(0===t?.recursionLimit)throw new Error("Recursion limit reached.");n=await n.invoke(e,this._patchConfig(t,r?.getChild(),(t?.recursionLimit??25)-1))}return n}async invoke(e,t){return this._callWithConfig(this._invoke,e,t)}async*_transform(e,t,r){let n;for await(const t of e)if(void 0===n)n=t;else try{n=Pe(n,t)}catch(e){n=t}const a=await this.func(n,{config:r});if(a&&ze.isRunnable(a)){if(0===r?.recursionLimit)throw new Error("Recursion limit reached.");const e=await a.stream(n,this._patchConfig(r,t?.getChild(),(r?.recursionLimit??25)-1));for await(const t of e)yield t}else yield a}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){return Ie.fromAsyncGenerator(this.transform(async function*(){yield e}(),t))}}class Ye extends ze{static lc_name(){return"RunnableWithFallbacks"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"runnable",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fallbacks",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.runnable=e.runnable,this.fallbacks=e.fallbacks}*runnables(){yield this.runnable;for(const e of this.fallbacks)yield e}async invoke(e,t){const r=await ue.configure(t?.callbacks,void 0,t?.tags,void 0,t?.metadata),n=await(r?.handleChainStart(this.toJSON(),qe(e,"input"),void 0,void 0,void 0,void 0,t?.runName));let a;for(const r of this.runnables())try{const a=await r.invoke(e,this._patchConfig(t,n?.getChild()));return await(n?.handleChainEnd(qe(a,"output"))),a}catch(e){void 0===a&&(a=e)}if(void 0===a)throw new Error("No error stored at end of fallback.");throw await(n?.handleChainError(a)),a}async batch(e,t,r){if(r?.returnExceptions)throw new Error("Not implemented.");const n=this._getOptionsList(t??{},e.length),a=await Promise.all(n.map((e=>ue.configure(e?.callbacks,void 0,e?.tags,void 0,e?.metadata)))),i=await Promise.all(a.map(((t,r)=>t?.handleChainStart(this.toJSON(),qe(e[r],"input"),void 0,void 0,void 0,void 0,n[r].runName))));let s;for(const t of this.runnables())try{const a=await t.batch(e,i.map(((e,t)=>this._patchConfig(n[t],e?.getChild()))),r);return await Promise.all(i.map(((e,t)=>e?.handleChainEnd(qe(a[t],"output"))))),a}catch(e){void 0===s&&(s=e)}if(!s)throw new Error("No error stored at end of fallbacks.");throw await Promise.all(i.map((e=>e?.handleChainError(s)))),s}}function Ze(e){if("function"==typeof e)return new Qe({func:e});if(ze.isRunnable(e))return e;if(Array.isArray(e)||"object"!=typeof e)throw new Error("Expected a Runnable, function or object.\nInstead got an unsupported type.");{const t={};for(const[r,n]of Object.entries(e))t[r]=Ze(n);return new Ke({steps:t})}}class Xe extends ze{static lc_name(){return"RunnableAssign"}constructor(e){e instanceof Ke&&(e={mapper:e}),super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"mapper",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.mapper=e.mapper}async invoke(e,t){const r=await this.mapper.invoke(e,t);return{...e,...r}}async*_transform(e,t,r){const n=this.mapper.getStepsKeys(),[a,i]=ke(e),s=this.mapper.transform(i,this._patchConfig(r,t?.getChild())),o=s.next();for await(const e of a){if("object"!=typeof e||Array.isArray(e))throw new Error("RunnableAssign can only be used with objects as input, got "+typeof e);const t=Object.fromEntries(Object.entries(e).filter((([e])=>!n.includes(e))));Object.keys(t).length>0&&(yield t)}yield(await o).value;for await(const e of s)yield e}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){return Ie.fromAsyncGenerator(this.transform(async function*(){yield e}(),t))}}class et extends ze{static lc_name(){return"RunnablePick"}constructor(e){("string"==typeof e||Array.isArray(e))&&(e={keys:e}),super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"keys",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.keys=e.keys}async _pick(e){if("string"==typeof this.keys)return e[this.keys];{const t=this.keys.map((t=>[t,e[t]])).filter((e=>void 0!==e[1]));return 0===t.length?void 0:Object.fromEntries(t)}}async invoke(e,t){return this._callWithConfig(this._pick.bind(this),e,t)}async*_transform(e){for await(const t of e){const e=await this._pick(t);void 0!==e&&(yield e)}}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){return Ie.fromAsyncGenerator(this.transform(async function*(){yield e}(),t))}}class tt extends ze{constructor(){super(...arguments),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","documents","transformers"]})}invoke(e,t){return this.transformDocuments(e)}}var rt=r(742),nt=Object.defineProperty;function at(e,t){return 1===e.length?[t.get(e.join(","))]:function(e,t){let r=Array.from({length:e.length},((e,t)=>({start:t,end:t+1})));for(;r.length>1;){let n=null;for(let a=0;a<r.length-1;a++){const i=e.slice(r[a].start,r[a+1].end),s=t.get(i.join(","));null!=s&&(null==n||s<n[0])&&(n=[s,a])}if(null==n)break;{const e=n[1];r[e]={start:r[e].start,end:r[e+1].end},r.splice(e+1,1)}}return r}(e,t).map((r=>t.get(e.slice(r.start,r.end).join(",")))).filter((e=>null!=e))}var it,st=class{specialTokens;inverseSpecialTokens;patStr;textEncoder=new TextEncoder;textDecoder=new TextDecoder("utf-8");rankMap=new Map;textMap=new Map;constructor(e,t){this.patStr=e.pat_str;const r=e.bpe_ranks.split("\n").filter(Boolean).reduce(((e,t)=>{const[r,n,...a]=t.split(" "),i=Number.parseInt(n,10);return a.forEach(((t,r)=>e[t]=i+r)),e}),{});for(const[e,t]of Object.entries(r)){const r=rt.toByteArray(e);this.rankMap.set(r.join(","),t),this.textMap.set(t,r)}this.specialTokens={...e.special_tokens,...t},this.inverseSpecialTokens=Object.entries(this.specialTokens).reduce(((e,[t,r])=>(e[r]=this.textEncoder.encode(t),e)),{})}encode(e,t=[],r="all"){const n=new RegExp(this.patStr,"ug"),a=st.specialTokenRegex(Object.keys(this.specialTokens)),i=[],s=new Set("all"===t?Object.keys(this.specialTokens):t),o=new Set("all"===r?Object.keys(this.specialTokens).filter((e=>!s.has(e))):r);if(o.size>0){const t=st.specialTokenRegex([...o]),r=e.match(t);if(null!=r)throw new Error(`The text contains a special token that is not allowed: ${r[0]}`)}let l=0;for(;;){let t=null,r=l;for(;a.lastIndex=r,t=a.exec(e),null!=t&&!s.has(t[0]);)r=t.index+1;const o=t?.index??e.length;for(const t of e.substring(l,o).matchAll(n)){const e=this.textEncoder.encode(t[0]),r=this.rankMap.get(e.join(","));null==r?i.push(...at(e,this.rankMap)):i.push(r)}if(null==t)break;let c=this.specialTokens[t[0]];i.push(c),l=t.index+t[0].length}return i}decode(e){const t=[];let r=0;for(let n=0;n<e.length;++n){const a=e[n],i=this.textMap.get(a)??this.inverseSpecialTokens[a];null!=i&&(t.push(i),r+=i.length)}const n=new Uint8Array(r);let a=0;for(const e of t)n.set(e,a),a+=e.length;return this.textDecoder.decode(n)}};((e,t,r)=>{t in e?nt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(st,"symbol"!=typeof(it="specialTokenRegex")?it+"":it,(e=>new RegExp(e.map((e=>e.replace(/[\\^$*+?.()|[\]{}]/g,"\\$&"))).join("|"),"g")));class ot extends tt{constructor(e){if(super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","document_transformers","text_splitters"]}),Object.defineProperty(this,"chunkSize",{enumerable:!0,configurable:!0,writable:!0,value:1e3}),Object.defineProperty(this,"chunkOverlap",{enumerable:!0,configurable:!0,writable:!0,value:200}),Object.defineProperty(this,"keepSeparator",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lengthFunction",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.chunkSize=e?.chunkSize??this.chunkSize,this.chunkOverlap=e?.chunkOverlap??this.chunkOverlap,this.keepSeparator=e?.keepSeparator??this.keepSeparator,this.lengthFunction=e?.lengthFunction??(e=>e.length),this.chunkOverlap>=this.chunkSize)throw new Error("Cannot have chunkOverlap >= chunkSize")}async transformDocuments(e,t={}){return this.splitDocuments(e,t)}splitOnSeparator(e,t){let r;if(t)if(this.keepSeparator){const n=t.replace(/[/\-\\^$*+?.()|[\]{}]/g,"\\$&");r=e.split(new RegExp(`(?=${n})`))}else r=e.split(t);else r=e.split("");return r.filter((e=>""!==e))}async createDocuments(e,t=[],r={}){const n=t.length>0?t:new Array(e.length).fill({}),{chunkHeader:i="",chunkOverlapHeader:s="(cont'd) ",appendChunkOverlapHeader:o=!1}=r,l=new Array;for(let t=0;t<e.length;t+=1){const r=e[t];let c=1,u=null,h=-1;for(const e of await this.splitText(r)){let d=i;const p=r.indexOf(e,h+1);if(null===u)c+=this.numberOfNewLines(r,0,p);else{const e=h+await this.lengthFunction(u);e<p?c+=this.numberOfNewLines(r,e,p):e>p&&(c-=this.numberOfNewLines(r,p,e)),o&&(d+=s)}const f=this.numberOfNewLines(e),m=n[t].loc&&"object"==typeof n[t].loc?{...n[t].loc}:{};m.lines={from:c,to:c+f};const g={...n[t],loc:m};d+=e,l.push(new a({pageContent:d,metadata:g})),c+=f,u=e,h=p}}return l}numberOfNewLines(e,t,r){return(e.slice(t,r).match(/\n/g)||[]).length}async splitDocuments(e,t={}){const r=e.filter((e=>void 0!==e.pageContent)),n=r.map((e=>e.pageContent)),a=r.map((e=>e.metadata));return this.createDocuments(n,a,t)}joinDocs(e,t){const r=e.join(t).trim();return""===r?null:r}async mergeSplits(e,t){const r=[],n=[];let a=0;for(const i of e){const e=await this.lengthFunction(i);if(a+e+(n.length>0?t.length:0)>this.chunkSize&&(a>this.chunkSize&&console.warn(`Created a chunk of size ${a}, +\nwhich is longer than the specified ${this.chunkSize}`),n.length>0)){const i=this.joinDocs(n,t);for(null!==i&&r.push(i);a>this.chunkOverlap||a+e>this.chunkSize&&a>0;)a-=await this.lengthFunction(n[0]),n.shift()}n.push(i),a+=e}const i=this.joinDocs(n,t);return null!==i&&r.push(i),r}}class lt extends ot{static lc_name(){return"RecursiveCharacterTextSplitter"}constructor(e){super(e),Object.defineProperty(this,"separators",{enumerable:!0,configurable:!0,writable:!0,value:["\n\n","\n"," ",""]}),this.separators=e?.separators??this.separators,this.keepSeparator=e?.keepSeparator??!0}async _splitText(e,t){const r=[];let n,a=t[t.length-1];for(let r=0;r<t.length;r+=1){const i=t[r];if(""===i){a=i;break}if(e.includes(i)){a=i,n=t.slice(r+1);break}}const i=this.splitOnSeparator(e,a);let s=[];const o=this.keepSeparator?"":a;for(const e of i)if(await this.lengthFunction(e)<this.chunkSize)s.push(e);else{if(s.length){const e=await this.mergeSplits(s,o);r.push(...e),s=[]}if(n){const t=await this._splitText(e,n);r.push(...t)}else r.push(e)}if(s.length){const e=await this.mergeSplits(s,o);r.push(...e)}return r}async splitText(e){return this._splitText(e,this.separators)}static fromLanguage(e,t){return new lt({...t,separators:lt.getSeparatorsForLanguage(e)})}static getSeparatorsForLanguage(e){if("cpp"===e)return["\nclass ","\nvoid ","\nint ","\nfloat ","\ndouble ","\nif ","\nfor ","\nwhile ","\nswitch ","\ncase ","\n\n","\n"," ",""];if("go"===e)return["\nfunc ","\nvar ","\nconst ","\ntype ","\nif ","\nfor ","\nswitch ","\ncase ","\n\n","\n"," ",""];if("java"===e)return["\nclass ","\npublic ","\nprotected ","\nprivate ","\nstatic ","\nif ","\nfor ","\nwhile ","\nswitch ","\ncase ","\n\n","\n"," ",""];if("js"===e)return["\nfunction ","\nconst ","\nlet ","\nvar ","\nclass ","\nif ","\nfor ","\nwhile ","\nswitch ","\ncase ","\ndefault ","\n\n","\n"," ",""];if("php"===e)return["\nfunction ","\nclass ","\nif ","\nforeach ","\nwhile ","\ndo ","\nswitch ","\ncase ","\n\n","\n"," ",""];if("proto"===e)return["\nmessage ","\nservice ","\nenum ","\noption ","\nimport ","\nsyntax ","\n\n","\n"," ",""];if("python"===e)return["\nclass ","\ndef ","\n\tdef ","\n\n","\n"," ",""];if("rst"===e)return["\n===\n","\n---\n","\n***\n","\n.. ","\n\n","\n"," ",""];if("ruby"===e)return["\ndef ","\nclass ","\nif ","\nunless ","\nwhile ","\nfor ","\ndo ","\nbegin ","\nrescue ","\n\n","\n"," ",""];if("rust"===e)return["\nfn ","\nconst ","\nlet ","\nif ","\nwhile ","\nfor ","\nloop ","\nmatch ","\nconst ","\n\n","\n"," ",""];if("scala"===e)return["\nclass ","\nobject ","\ndef ","\nval ","\nvar ","\nif ","\nfor ","\nwhile ","\nmatch ","\ncase ","\n\n","\n"," ",""];if("swift"===e)return["\nfunc ","\nclass ","\nstruct ","\nenum ","\nif ","\nfor ","\nwhile ","\ndo ","\nswitch ","\ncase ","\n\n","\n"," ",""];if("markdown"===e)return["\n## ","\n### ","\n#### ","\n##### ","\n###### ","```\n\n","\n\n***\n\n","\n\n---\n\n","\n\n___\n\n","\n\n","\n"," ",""];if("latex"===e)return["\n\\chapter{","\n\\section{","\n\\subsection{","\n\\subsubsection{","\n\\begin{enumerate}","\n\\begin{itemize}","\n\\begin{description}","\n\\begin{list}","\n\\begin{quote}","\n\\begin{quotation}","\n\\begin{verse}","\n\\begin{verbatim}","\n\\begin{align}","$$","$","\n\n","\n"," ",""];if("html"===e)return["<body>","<div>","<p>","<br>","<li>","<h1>","<h2>","<h3>","<h4>","<h5>","<h6>","<span>","<table>","<tr>","<td>","<th>","<ul>","<ol>","<header>","<footer>","<nav>","<head>","<style>","<script>","<meta>","<title>"," ",""];if("sol"===e)return["\npragma ","\nusing ","\ncontract ","\ninterface ","\nlibrary ","\nconstructor ","\ntype ","\nfunction ","\nevent ","\nmodifier ","\nerror ","\nstruct ","\nenum ","\nif ","\nfor ","\nwhile ","\ndo while ","\nassembly ","\n\n","\n"," ",""];throw new Error(`Language ${e} is not supported.`)}}}},i={};function s(e){var t=i[e];if(void 0!==t)return t.exports;var r=i[e]={id:e,loaded:!1,exports:{}};return a[e](r,r.exports,s),r.loaded=!0,r.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",r="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",n=e=>{e&&!e.d&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},s.a=(a,i,s)=>{var o;s&&((o=[]).d=1);var l,c,u,h=new Set,d=a.exports,p=new Promise(((e,t)=>{u=t,c=e}));p[t]=d,p[e]=e=>(o&&e(o),h.forEach(e),p.catch((e=>{}))),a.exports=p,i((a=>{var i;l=(a=>a.map((a=>{if(null!==a&&"object"==typeof a){if(a[e])return a;if(a.then){var i=[];i.d=0,a.then((e=>{s[t]=e,n(i)}),(e=>{s[r]=e,n(i)}));var s={};return s[e]=e=>e(i),s}}var o={};return o[e]=e=>{},o[t]=a,o})))(a);var s=()=>l.map((e=>{if(e[r])throw e[r];return e[t]})),c=new Promise((t=>{(i=()=>t(s)).r=0;var r=e=>e!==o&&!h.has(e)&&(h.add(e),e&&!e.d&&(i.r++,e.push(i)));l.map((t=>t[e](r)))}));return i.r?c:s()}),(e=>(e?u(p[r]=e):c(d),n(o)))),o&&(o.d=0)},s.d=(e,t)=>{for(var r in t)s.o(t,r)&&!s.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),s(138)})();